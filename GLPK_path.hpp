#include <iostream>
#include <cstdlib>
#include <glpk.h>
#include <igraph.h>

typedef igraph_integer_t myint;

using namespace std;

class GLPK_path {
public:
  glp_prob* lp;
  int* ia;
  int* ja;
  double* ar;
  myint n;
  size_t nPaths;
  
  GLPK_path( vector< vector< myint > >& v_paths,
	     myint in_n, // number of vertices
	     vector< double >& v_node_costs
	     ) {
    n = in_n;
    size_t k = v_paths.size();
    nPaths = k;
    //the constraint matrix will have k rows
    //(one for each path) and n columns 

    lp = glp_create_prob();
    glp_set_obj_dir(lp, GLP_MIN);
    glp_add_rows( lp, k ); //For each path, we have a constraint
    for (size_t i = 1; i <= k; ++i) {
      glp_set_row_bnds( lp, i, GLP_LO, 1.0, 0.0 ); 
    }

    glp_add_cols( lp, n );
    for (size_t i = 1; i <= n; ++i) {
      glp_set_col_kind( lp, i, GLP_BV ); //whether we choose vertex
      glp_set_obj_coef( lp, i, v_node_costs[ i - 1 ] ); //unweighted for now
    }
    cerr << "Allocating matrices..." << endl;
    
    ia = new int[ n * k + 1];
    ja = new int[ n * k + 1];
    ar = new double[ n * k + 1];

    size_t index = 1; //index of current element in the constraint matrix
    
    for (size_t i = 0; i < k; ++i) {
      //for each path, add the corresponding constraint
      //ignore s and t, as usual
      if (v_paths[i].size() > 2) { //rule out (s,t) 
	for (size_t j = 1; j < (v_paths[i].size() - 1); ++j) {
	  ia[ index ] = i + 1;
	  ja[ index ] = v_paths[i][j] + 1; //a[ i,
	  ar[ index ] = 1.0;
	  ++index;
	}
      }
    }
    cerr << "Creating matrix...";
    //all path constraints added, create the matrix
    glp_load_matrix( lp, (index - 1), ia, ja, ar );
    cerr << "GLPK instance constructed." << endl;
  }

  void LP_solve( vector< double >& W_LP ) {
    W_LP.clear();
    glp_simplex( lp, NULL );
    for (size_t i = 0; i < n; ++i) {
      W_LP.push_back( glp_get_col_prim( lp, i + 1 ) );

    }
  }
  
  void GLPK_solve( vector< myint >& W //the variables chosen
		   ) {
    W.clear();
    
    glp_simplex( lp, NULL );
    glp_intopt( lp, NULL );

    if (glp_mip_status( lp ) != GLP_OPT ) {
      cerr << "Optimal solution not found...\n";
      return;
    }
    
    for (size_t i = 0; i < n; ++i) {
      //      cerr << glp_get_col_prim( lp, i + 1 ) << endl;
      if (glp_mip_col_val( lp, i + 1) == 1) {
	W.push_back( i );
      }
    }

    // for (size_t i = 0; i < nPaths; ++i ) {
      

    // }
  }
    
  ~ GLPK_path() {
    delete[] ia;
    delete[] ja;
    delete[] ar;
    glp_delete_prob( lp );
  }
  
};


