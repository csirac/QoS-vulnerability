#include <iostream>
#include <cstdio>
#include <string>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <igraph.h>
#include <vector>
#include <random>
#include <set>
#include "GLPK_path.hpp"
#include <iomanip>
#include <ctime>
#include <thread>
#include <mutex>
#include <chrono>

using namespace std;
typedef igraph_integer_t myint;
typedef igraph_vector_t ivector;

//global random number generator
std::random_device rd;
std::mt19937 gen(rd());

//global thread mutex
std::mutex mtx;
//global nthreads
unsigned nthreads = 7;

enum Sample_type { NAIVE=0, FVALID=1, ALL=2 };

struct presult {
  string alg_name;
  double sln_cost;
  double run_time;
  string type;
  string ptype;
};

struct node_pair {
  myint s;
  myint t;
};

inline bool file_exists (const std::string& name) {
  if (FILE *file = fopen(name.c_str(), "r")) {
    fclose(file);
    return true;
  } else {
    return false;
  }   
}

void remove_vertices( //preserve vertex ids
		     igraph_t& G,
		     vector< myint >& v ) {
  ivector eids;
  igraph_vector_init( &eids, 0 );
  ivector all_eids;
  igraph_vector_init( &all_eids, 0 );

  for ( unsigned i = 0; i < v.size(); ++i) {
    igraph_incident( &G, &eids, v[i], IGRAPH_ALL );

    for (unsigned j = 0; j < igraph_vector_size( &eids ); ++j) {
      igraph_vector_push_back( &all_eids, VECTOR( eids )[j] );
    }
  }

  igraph_delete_edges( &G, igraph_ess_vector( &all_eids ) );
  igraph_vector_destroy( &eids );
  igraph_vector_destroy( &all_eids );

}

void remove_vertex( // preserves vertex ids
		   igraph_t& G,
		   myint v
		    ) {
  ivector eids;
  igraph_vector_init( &eids, 0 );
  igraph_incident( &G, &eids, v, IGRAPH_ALL );

  igraph_delete_edges( &G, igraph_ess_vector( &eids ) );
  igraph_vector_destroy( &eids );
}

 
void print_results_no_formatting
( vector < presult >& v_res, ostream& os,
		    int col_width = 10,
		    bool b_header = false )

{
  if (b_header) {
    //print header
    os << "#";
    unsigned col = 1;
    for (unsigned i = 0; i < v_res.size(); ++i) {
      os << col++ << '_' << v_res[i].alg_name << ' ';
      if (v_res[i].type != "param")
	os << col++ << "_time_" << v_res[i].alg_name << ' ';

    }

    os << endl;
  }

  for (unsigned i = 0; i < v_res.size(); ++i) {
    if ( v_res[i].type != "param" ) {
      os << fixed << setprecision( 2 );
      os << v_res[i].sln_cost << ' ';
      os << v_res[i].run_time << ' ';
    } else {
      if (v_res[i].ptype == "int" ) {
	os << fixed << setprecision( 0 );
      } else {
	os << fixed << setprecision( 3 );
      }
      
      os << v_res[i].sln_cost << ' ';
    }
  }

  os << endl;
}


void print_results( vector < presult >& v_res, ostream& os,
		    int col_width = 10,
		    bool b_header = false )

{
  if (b_header) {
    //print header
    os << "#";
    for (unsigned i = 0; i < v_res.size(); ++i) {
      os << setw( col_width );
      os << 2*i + 1;
      os << setw( col_width );
      os << 2*i + 2;
    }
    os << endl;
    os << "#";
    for (unsigned i = 0; i < v_res.size(); ++i) {
      os << setw( col_width );
      os << v_res[i].alg_name;
    }
    
    for (unsigned i = 0; i < v_res.size(); ++i) {
      os << setw( col_width );
      os << v_res[i].alg_name;

    }

    os << endl;
  }

  for (unsigned i = 0; i < v_res.size(); ++i) {
    os << setw( col_width ) << fixed << setprecision( 2 );
    os << v_res[i].sln_cost;
  }

  for (unsigned i = 0; i < v_res.size(); ++i) {
    os << setw( col_width ) << fixed << setprecision( 2 );
    os << v_res[i].run_time;
  }

  os << endl;
}

template <typename T>
void print_vector( vector< T >& v, ostream& os = cout ) {
  for (unsigned i = 0; i < v.size(); ++i) {
    os << v[i] << ' ';

  }

  os << endl;
}

template <typename T>
bool vcontain( vector< T >& v, T val ) {
  for (unsigned i = 0; i < v.size(); ++i) {
    if (v[i] == val)
      return true;
  }

  return false;
}

struct node_edge {
  myint n;
  myint v_n; //(v_n, w_n) is the edge replacing node n
  myint w_n;
};

double path_length(
		   igraph_t& G,
		   vector< myint >& path,
		   vector< double >& v_ew //edge weights
		   ) {
  double length = 0.0;
  for (unsigned i = 0; i < (path.size() - 1);
       ++i) {
    myint eid;
    myint n_from = path[i];
    myint n_to = path[i + 1];
    igraph_get_eid( &G, &eid, n_from, n_to, true, true );
    length += v_ew[ eid ];
  }

  return length;
}

bool rec_sample( igraph_t& G,
		 vector< myint >& path,
		 myint& t,
		 double& prob, //the function calling should pass 1.0
		 vector< double >& v_ew,
		 double& T,
		 unsigned& n_backtracks,
		 unsigned& max_backtracks,
		 vector< myint >& W,
		 double curr_length
	    ){
  myint last_vertex = path.back();

  ivector out_neis;
  igraph_vector_init( &out_neis, 0 );
  vector< myint > v_neis;
  //sample the next node
  igraph_neighbors( &G, &out_neis, last_vertex, IGRAPH_OUT );

  //only want neighbors not currently in the path
  //and not in W
  for (unsigned i = 0; i < igraph_vector_size( &out_neis ); ++i) {
    if ( !vcontain( path, ((myint) VECTOR( out_neis )[i] )) ) {
      //      if (!vcontain( W, ((myint) VECTOR( out_neis )[i] )) ) {
	v_neis.push_back( VECTOR( out_neis )[i] );
	//      }
    }
  }

  igraph_vector_destroy( &out_neis );

  if (v_neis.size() == 0) {
    //this path cannot continue without a cycle
    return false;
  }

  //until successfully making it to t,
  //we will sample each neighbor
  
  //which neighbors we have tried
  vector< bool > b_tried ( v_neis.size(), false );
  unsigned n_left = v_neis.size(); //neighbors left
  std::uniform_int_distribution< unsigned > dist(0, v_neis.size() - 1 );
  unsigned next_vertex;
  double old_prob = prob;
  prob *= ( 1.0 / v_neis.size() );
  unsigned tmp;
  do {
    //pick a neighbor uniformly randomly

    do {
      tmp = dist( gen );
      
    } while(
	    ( b_tried[ tmp ] == true ) 
	    );
    
    next_vertex = v_neis[ tmp ];
    n_left = n_left - 1;
    path.push_back( next_vertex );
    b_tried[ tmp ] = true;
    
    myint eid;
    igraph_get_eid( &G, &eid, last_vertex, next_vertex, true, true );
    double plength = curr_length + v_ew[ eid ];
    if ( plength < T ) {
      if (next_vertex == t) {
	//we have reached the destination
	return true;
      }

      if ( rec_sample( G, path, t, prob, v_ew, T, n_backtracks,
			 max_backtracks, W, plength ) ) {
	  //a valid path has been found this way
	  //so quit
	return true;
      } else {
	  //no valid path this way
	  //backtrack
	++n_backtracks;
	if (max_backtracks > 0) {
	  if (n_backtracks > max_backtracks) {
	    return false;
	    
	  }
	}
	path.pop_back();
      }
	
    } else {
	//cannot continue this way, threshold exceeded
	//backtrack
	++n_backtracks;
	path.pop_back();
	if (max_backtracks > 0) {
	  if (n_backtracks > max_backtracks) {
	    return false;
	    
	  }
	}
    }
  } while (n_left > 0);

  //if we make it here, there are no neighbors
  //left to try. We need to backtrack last_vertex
  //reset prob
  prob = old_prob;
  return false;
}



bool sample_path_2(igraph_t& G,
		 myint s, myint t, double& prob, vector< myint >& path,
		 double T, vector< double >& v_ew ) {
  path.clear();
  path.push_back( s );
  prob = 1.0;

  ivector out_neis;
  igraph_vector_init( &out_neis, 0 );
  vector< myint > v_neis;
  while ( path_length( G, path, v_ew ) < T ) {
    myint last_vertex = path.back();
    v_neis.clear();
    //sample the next node
    igraph_neighbors( &G, &out_neis, last_vertex, IGRAPH_OUT );

    //only want neighbors not currently in the path
    for (unsigned i = 0; i < igraph_vector_size( &out_neis ); ++i) {
      if ( !vcontain( path, ((myint) VECTOR( out_neis )[i] )) ) {
	v_neis.push_back( VECTOR( out_neis )[i] );
      }
    }

    if (v_neis.size() == 0) {
      //this path cannot continue without a cycle
      igraph_vector_destroy( &out_neis );
      return false;
    }
    
    //pick a neighbor uniformly randomly
    std::uniform_int_distribution< unsigned > dist(0, v_neis.size() - 1 );
    unsigned next_vertex = v_neis[ dist( gen ) ];
    prob *= ( 1.0 / v_neis.size() );
    path.push_back( next_vertex );
    if (next_vertex == t) {
      igraph_vector_destroy( &out_neis );
      return true;
    }
  }

  //path length is \ge T, no valid paths from this point
  igraph_vector_destroy( &out_neis );
  return false;

}

bool sample_path(igraph_t& G,
		 myint s, myint t, 
		 double& prob, vector< myint >& path,
		 double T, vector< double >& v_ew ) {
  path.clear();
  path.push_back( s );
  prob = 1.0;

  ivector out_neis;
  igraph_vector_init( &out_neis, 0 );
  vector< myint > v_neis;
  double curr_length = 0.0;
  myint eid;

  while ( curr_length < T ) {
    myint last_vertex = path.back();
    v_neis.clear();
    //sample the next node
    igraph_neighbors( &G, &out_neis, last_vertex, IGRAPH_OUT );

    //only want neighbors not currently in the path
    for (unsigned i = 0; i < igraph_vector_size( &out_neis ); ++i) {
      if ( !vcontain( path, ((myint) VECTOR( out_neis )[i] )) ) {
	v_neis.push_back( VECTOR( out_neis )[i] );
      }
    }

    if (v_neis.size() == 0) {
      //this path cannot continue without a cycle
      igraph_vector_destroy( &out_neis );
      return false;
    }
    
    //pick a neighbor uniformly randomly
    std::uniform_int_distribution< unsigned > dist(0, v_neis.size() - 1 );
    unsigned next_vertex = v_neis[ dist( gen ) ];
    prob *= ( 1.0 / v_neis.size() );
    path.push_back( next_vertex );

    igraph_get_eid( &G, &eid, last_vertex, next_vertex, true, true );

    curr_length += v_ew[ eid ];
    if (next_vertex == t) {
      igraph_vector_destroy( &out_neis );
      if (curr_length < T) {
	return true;
      } else
	return false;
    }
  }

  //path length is \ge T, no valid paths from this point
  igraph_vector_destroy( &out_neis );
  return false;

}

bool is_path_valid( igraph_t& G,
		    vector< myint >& path,
		    double T,
		    vector< double >& v_ew ) {
  myint eid;
  myint n_from, n_to;
  double length = 0.0;

  for (unsigned i = 0; i < path.size() - 1 ; ++i ) {
    n_from = path[i];
    n_to = path[i + 1];

    igraph_get_eid( &G, &eid, n_from, n_to, true, false );
    if (eid == -1)
      return false;

    length += v_ew[ eid ];
  }

  return ( length < T );
}

void L_samples (
		Sample_type which_method,
		igraph_t& G,
		myint s,
		myint t,
		vector< double >& v_ew,
		double T, unsigned L,
		vector< double >& npaths,
		double& n_valid,
		unsigned& max_backtracks,
		vector< myint >& W ) {
  myint n = igraph_vcount( &G );
  vector< double > my_npaths( n, 0.0 );
  bool b_sample;
  vector< myint > path;
  double prob;
  unsigned u_valid = 0;

  for (unsigned i = 0; i < L; ++i) {
    //    if ( i % ( unsigned ( 0.2 * L ) ) == 0 ) {
      //      cout << ((double) i) / L << "    \r";
      //      cout.flush();
    //    }
    path.clear();
    prob = 1.0;
    if (which_method == FVALID) {
      unsigned n_backtracks = 0;
      path.push_back( s );
      b_sample = rec_sample( G, path, t, prob, v_ew, T,
			     n_backtracks, max_backtracks, W, 0.0 );

    } else {
      b_sample = sample_path( G,
			      s, t, prob, path,
			      T, v_ew );
    }

    if (b_sample) { //if the sample is a valid path
      //first node is s, last is t exclude those nodes
      ++u_valid;
      // print_vector( path );
      // if ( is_path_valid( G, path, T, v_ew ) ) {
      // 	cout << "valid" << endl;
      // } else {
      // 	cout << "invalid" << endl;
      // }

      for (unsigned k = 1; k < (path.size() - 1); ++k) {
	//for each node on the path, update its estimator
	my_npaths[ path[ k ] ] += 1.0 / ( prob ); // / ( prob );
	//	cout << path[k] << ' ';
      }
      //      cout << t << endl;
    }
  }
  
  mtx.lock();
  for (unsigned i = 0; i < npaths.size(); ++i) {
    npaths[i] += my_npaths[i];
  }
  n_valid += static_cast< double >( u_valid );
  mtx.unlock();
}


void remove_edges_between_pairs(
				//the graph
				igraph_t& G,
				//the set of target pairs
				vector< node_pair >& v_S
				) {
  myint s_i, t_i;
  myint eid;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    s_i = v_S[i].s;
    t_i = v_S[i].t;

    //determine if an edge exists between this pair
    //if so, there is no way to pseudo-cut them
    //without removing one of the pair
    igraph_get_eid( &G, &eid, s_i, t_i, true, false );

    //if the edge does not exist, eid = -1
    if (eid != -1) {
      //the edge exists, so we need to remove it
      igraph_delete_edges( &G, igraph_ess_1( eid ) );
    }
  }
}

void weight_vector_from_matrix(
			       igraph_t& G,
			       vector< double >& v_ew,
			       vector< vector < double > >& wA ) {
  myint n = igraph_vcount( &G );
  myint m = igraph_ecount( &G );
  myint eid;
  v_ew.assign( m, 1.0 );
  for (myint i = 0; i < n; ++i ) {
    for (myint j = 0; j < n; ++j ) {
      igraph_get_eid( &G, &eid, i, j, true, false );
      if (eid != -1) {
	//this edge exists, so let's assign the weight
	v_ew[ eid ] = wA[i][j];
      }
    }
  }
  
}

template <typename T>
void ivector_from_vector(
			 vector< T >& v_cpp,
			 //iv should be initialized and empty
			 ivector& iv 
			 ) {
  for (unsigned i = 0; i < v_cpp.size(); ++i) {
    igraph_vector_push_back( &iv, v_cpp[i] );
  }
}

template <typename T>
void vector_from_ivector(
			 vector< T >& v_cpp,
			 ivector& iv 
			 ) {
  for (unsigned i = 0; i < igraph_vector_size( &iv ); ++i) {
    v_cpp.push_back( (T)( VECTOR( iv )[i]  ));
  }
}

void get_out_neighbors(
		       igraph_t& G,
		       myint& v,
		       vector< myint >& v_neis ) {
  v_neis.clear();
  ivector neis;
  igraph_vector_init( &neis, 0 );
  igraph_neighbors( &G, &neis, v, IGRAPH_OUT );
  
  vector_from_ivector( v_neis, neis );
  igraph_vector_destroy( &neis );
}

double get_shortest_path(
			 vector< myint >& path,
			 myint s,
			 myint t,
			 igraph_t& G,
			 vector< vector< double > >& wA ) {
  path.clear();
  vector< double > v_ew;
  weight_vector_from_matrix( G, v_ew, wA );
  ivector iv_ew;
  igraph_vector_init( &iv_ew, 0 );
  ivector_from_vector( v_ew, iv_ew );

  // //first check if the distance is IGRAPH_INFINITY
  // igraph_matrix_t res;
  // igraph_matrix_init( &res, 1, 1 );
  // igraph_shortest_paths_dijkstra( &G_copy,
  // 				  &res,
  // 				  igraph_vss_1(s),
  // 				  igraph_vss_1(t),
  // 				  &iv_ew,
  // 				  IGRAPH_OUT
  // 				  );
    
  // if ( MATRIX( res, 0, 0) != IGRAPH_INFINITY ) {
    //a path exists, so find it
    igraph_vector_ptr_t vertices;
    igraph_vector_t v;
    igraph_vector_init( &v, 0 );
    igraph_vector_ptr_init( &vertices, 0 );
    igraph_vector_ptr_push_back( &vertices, &v );
    igraph_get_shortest_paths_dijkstra( &G,
					&vertices,
					NULL,
					s,
					igraph_vss_1( t ),
					&iv_ew,
					IGRAPH_OUT,
					NULL,
					NULL );

  
    for (unsigned j = 0; j < igraph_vector_size( &v );
	 ++j ) {
      path.push_back( igraph_vector_e( &v, j ) );
    }
    
    igraph_vector_destroy( &v );
    igraph_vector_destroy( &iv_ew );
    igraph_vector_ptr_destroy( &vertices );

    if (path.size() > 0) {
      return path_length( G, path, v_ew );
    } else {
      return IGRAPH_INFINITY;
    }
  // } else {

  // }
}

bool pairs_T_sep2(
		 igraph_t& G,
		 vector< node_pair >& v_S,
		 double T,
		 vector < vector < double > >& wA
		 ) {
  

}

bool pairs_T_sep(
		 igraph_t& G,
		 vector< node_pair >& v_S,
		 double T,
		 vector < vector < double > >& wA
		 ) {
  vector< double > v_ew;
  weight_vector_from_matrix( G, v_ew, wA );
  ivector iv_ew;
  igraph_vector_init( &iv_ew, 0 );
  ivector_from_vector( v_ew, iv_ew );

  igraph_matrix_t res;
  igraph_matrix_init( &res, 1, 1 );
  myint s, t;
  bool rvalue = true;
  for (unsigned i = 0; i < v_S.size(); ++i ) {
    s = v_S[i].s;
    t = v_S[i].t;
    igraph_shortest_paths_dijkstra( &G,
    				    &res,
    				    igraph_vss_1(s),
    				    igraph_vss_1(t),
    				    &iv_ew,
    				    IGRAPH_OUT
    				    );
    
    if ( MATRIX( res, 0, 0) < T )
      rvalue = false;
  }

  igraph_matrix_destroy( &res );
  igraph_vector_destroy( &iv_ew );

  return rvalue;
}

void assign_random_weights(
			   igraph_t& G,
			   vector< double >& v_ew,
			   vector< vector < double > >& wA ) {
  std::uniform_real_distribution<> dis(0,1);
  
  myint n = igraph_vcount( &G );
  myint m = igraph_ecount( &G );

  v_ew.assign( m, 1.0 );
  vector < double > v_n( n, 1.0 );
  wA.assign( n, v_n );
  myint eid;
  for (myint i = 0; i < n; ++i ) {
    for (myint j = 0; j < n; ++j ) {
      wA[i][j] = 1.0 + dis( gen ); //Should be a random weight
    }
  }

  weight_vector_from_matrix( G, v_ew, wA );
  
}

void assign_costs( vector< double >& v_nc,
		   vector< node_pair >& v_S,
		   myint n,
		   unsigned& is_weighted) {
  std::uniform_real_distribution<> dis(0,1);
  
  vector< myint > pair_members;
  v_nc.assign( n, 1.0 );
  for (unsigned i = 0; i < v_S.size(); ++i ) {
    v_nc[ v_S[ i ].s ] = (double) n;
    v_nc[ v_S[ i ].t ] = (double) n;
  }
  
   for (unsigned i = 0; i < v_nc.size(); ++i) {
     if ( v_nc[i] < (double) n ) {
       if (is_weighted == 1) 
	 v_nc[ i ] = dis( gen ); //1.0
       else
	 v_nc[ i ] = 1.0;
     }
   }
}

double euclidean_distance( double x1, double y1, double x2, double y2 ) {
  double arg = (x1 - x2) * (x1 - x2) + (y1 - y2)*(y1 - y2);
  return sqrt( arg );
}

void assign_wint_costs( igraph_t& G, 
			vector< double >& v_nc,
			vector< node_pair >& v_S,
			myint n, double p,
			ivector& wint_x,
			ivector& wint_y ) {
  vector< double > x, y;
  vector_from_ivector( x, wint_x );
  vector_from_ivector( y, wint_y );

  cout << x.size() << endl;
  cout << y.size() << endl;

  std::uniform_real_distribution<> dis(0,1);

  vector< myint > pair_members;
  v_nc.assign( n, 1.0 );
  for (unsigned i = 0; i < v_S.size(); ++i ) {
    v_nc[ v_S[ i ].s ] = (double) n;
    v_nc[ v_S[ i ].t ] = (double) n;
  }

  vector <myint > v_terminals;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    myint tmp = v_S[i].s;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
    tmp = v_S[i].t;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
  }

 
   for (unsigned i = 0; i < v_nc.size(); ++i) {
     if ( v_nc[i] < (double) n ) {
       v_nc[ i ] = 1.0; //dis( gen ); //1.0
     }
   }

  //pick drones
   double drone_frac = 0.1;
   double sat_frac = 0.01;
   myint n_drones = static_cast< myint > ( drone_frac * n );
   myint n_sat = static_cast< myint > ( sat_frac * n );
   double drone_r = 2 * p;
   double sat_r = 4 * p;
   double drone_cost = 5.0;
   double sat_cost = 20.0;

   //now edit both connections and costs for 
   //drones, sats
   myint n_skip = 0;
   ivector edges_to_add;
   igraph_vector_init( &edges_to_add, 0 );

   for (myint i = 0; i < n_drones; ++i) {
     //while ( vcontain( v_terminals, i + n_skip ) )
     //       ++n_skip;
     if (! vcontain( v_terminals, i ) ) {
       //we've found a non-terminal
       //make it a drone
       myint d = i ;
       v_nc[ d ] = drone_cost;
       for (myint j = 0; j < n; ++j) {
	 if (j != d) {
	   if ( euclidean_distance( x[j], y[j], x[d], y[d]) < drone_r ) {
	     igraph_vector_push_back(&edges_to_add, j );
	     igraph_vector_push_back(&edges_to_add, d );
	     //	     igraph_vector_push_back(&edges_to_add, d );
	     //	     igraph_vector_push_back(&edges_to_add, j );
	     //	     cout << j << ' ' << d << endl;
	   }
	 }
       }

     }
   }
   for (myint i = n_drones; i < n_sat + n_drones; ++i) {
     //while ( vcontain( v_terminals, n_drones + i + n_skip ) )
     //++n_skip;
     if ( !vcontain( v_terminals, i ) ){
       //we've found a non-terminal
       //make it a satellite
       myint d = i;
       v_nc[ d ] = sat_cost;
       for (myint j = 0; j < n; ++j) {
	 if (j != d) {
	   if ( euclidean_distance( x[j], y[j], x[d], y[d]) < sat_r ) {
	     igraph_vector_push_back(&edges_to_add, j );
	     igraph_vector_push_back(&edges_to_add, d );
	     //	     igraph_vector_push_back(&edges_to_add, d );
	     //	     igraph_vector_push_back(&edges_to_add, j );
	   }
	 }
       }
     }

   }

   igraph_add_edges( &G, &edges_to_add, 0 );
   igraph_vector_destroy( &edges_to_add );
}


double cost_vector( vector< myint >& W,
		    vector< double >& v_nc ) {
  double rvalue = 0.0;
  for (unsigned i = 0; i < W.size(); ++i) {
    rvalue += v_nc[ W[i] ];
  }

  return rvalue;
}

bool list_paths(
		std::chrono::seconds& max_time,
		chrono::high_resolution_clock::time_point& t_start,
		unsigned t_call_count,
		igraph_t& G,
		vector< vector < myint > >& vpaths,
		//vector recording which paths each vertex
		//lies upon
		//needs to be initialized with empty vectors
		vector< vector < unsigned > >& v_path_membership,
		//path is a list of vertex ids
		vector< myint > path, 
		//the vertex at which to terminate
		myint& end,
		//the upper bound on path length
		double T,
		vector< double >& v_ew //edge weights
		) {
  t_call_count += 1;
  if (t_call_count > 0) { //don't want to check the time every call
    chrono::high_resolution_clock::time_point t_now = chrono::high_resolution_clock::now();
    if ( chrono::duration_cast< chrono::seconds > ( t_now - t_start ) > max_time ) {
      //we have run out of time
      return false;
    }

    //    t_call_count = 0;
  }

  myint last_vertex = path.back();
  path.push_back( -1 ); //reserve a potential next spot in the path
  //for each neighbor of last_vertex
  ivector neis;
  igraph_vector_init( &neis, 0 );
  igraph_neighbors( &G, &neis, last_vertex, IGRAPH_OUT );
  for (myint i = 0; i < igraph_vector_size( &neis ); ++i) {
    myint current_neighbor = VECTOR( neis )[i];
    //need to make sure the path doesn't already contain current_neighbor
    if (!(vcontain( path, current_neighbor))) {
      //then we can add the vertex to the path, as long as doing so
      //does not exceed the distance constraint
      //for now, unweighted distance
      path.back() = current_neighbor;
      if ( path_length( G, path, v_ew ) < T) {
	//have we reached the destination? 
	if ( current_neighbor == end ) {
	  //we have found a valid path
	  //update the path membership
	  for (unsigned j = 0; j < path.size(); ++j) {
	    v_path_membership[ path[ j ] ].push_back( vpaths.size() );
	    //vpaths.size() will correspond to the new index
	  }

	  vpaths.push_back( path );
	} else {
	  //continue exploring in this direction
	  list_paths( 
		     max_time, t_start, t_call_count,
		     G, vpaths, v_path_membership, path, end, T, v_ew);
	}
      }
    }
    
  }

  igraph_vector_destroy( &neis );
  return true;
}

void multi_list_paths ( 
		       bool& b_success,
		       chrono::seconds& max_time,
			chrono::high_resolution_clock::time_point& t_start,
		       vector< myint >& v_neis,
			igraph_t& G, 
			vector< vector< myint > >& vpaths,
			vector< vector< unsigned > >& v_path_membership,
			myint& start,
			myint& end,
			double T,
			vector< double >& v_ew ) {

  vector< vector < myint > > my_vpaths;
  myint n = igraph_vcount( &G );
  vector< unsigned > empty;
  vector< vector < unsigned > > my_v_path_membership (n, empty );
  vector< myint > path;
  //lock to access v_neis
  mtx.lock();
  while ( v_neis.size() > 0 ) {
    path.clear();
    path.push_back( start );
    path.push_back( v_neis.back() );
    v_neis.pop_back();
    mtx.unlock();

    //now enumerate all paths starting with s0, s1
    list_paths(max_time, t_start, 0, G, my_vpaths, my_v_path_membership, path, end, T, v_ew );
    
    mtx.lock();
    chrono::high_resolution_clock::time_point t_now = chrono::high_resolution_clock::now();

    if ( chrono::duration_cast< chrono::seconds > ( t_now - t_start ) > max_time ) {
      b_success = false;
      mtx.unlock();
      return;
    }

  }
  mtx.unlock();
  cerr << "here\n";
  //enumeration complete, add paths to results
  mtx.lock();
  size_t old_npaths = vpaths.size();
  for (unsigned i = 0; i < my_vpaths.size(); ++i) {
    vpaths.push_back( my_vpaths[i] );
  }

  for (unsigned i = 0; i < v_path_membership.size(); ++i) {
    for (unsigned j = 0; j < my_v_path_membership[i].size(); ++j) {
      v_path_membership[i].push_back( my_v_path_membership[ i ][ j ] + old_npaths );
    }
  }

  b_success = true;
  mtx.unlock();
  cerr << "mult_list returning\n";
}

void test_feasibility( igraph_t& G,
		       vector< myint >& W,
		       vector< vector < double > >& wA,
		       vector< node_pair >& v_S) {
  igraph_t G_copy;
  igraph_copy( &G_copy, &G );
  //delete W
  ivector iv_Wedges;
  igraph_vector_init( &iv_Wedges, 0 );
  ivector tmp_edges;
  igraph_vector_init( &tmp_edges, 0 );
  for (unsigned i = 0; i < W.size(); ++i) {
    igraph_incident( &G, &tmp_edges, W[i], IGRAPH_ALL );
    for (unsigned j = 0; j < igraph_vector_size( &tmp_edges ); ++j ) {
      igraph_vector_push_back( &iv_Wedges, VECTOR( tmp_edges )[j]);
    }
  }

  igraph_delete_edges( &G_copy, igraph_ess_vector( &iv_Wedges ) );

  igraph_vector_destroy( &iv_Wedges );
  // int igraph_shortest_paths_dijkstra(const igraph_t *graph,
  // 				     igraph_matrix_t *res,
  // 				     const igraph_vs_t from,
  // 				     const igraph_vs_t to,
  // 				     const igraph_vector_t *weights,
  // 				     igraph_neimode_t mode);
  

  myint s, t;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    s = v_S[i].s;
    t = v_S[i].t;

    vector< double > v_ew;
    weight_vector_from_matrix( G_copy, v_ew, wA );
    ivector iv_ew;
    igraph_vector_init( &iv_ew, 0 );
    ivector_from_vector( v_ew, iv_ew );
  
    igraph_matrix_t res;
    igraph_matrix_init( &res, 1, 1 );
    igraph_shortest_paths_dijkstra( &G_copy,
    				    &res,
    				    igraph_vss_1(s),
    				    igraph_vss_1(t),
    				    &iv_ew,
    				    IGRAPH_OUT
    				    );
    
    cout << "pair " << i << " (" << s << "," << t << "): "
    	 << MATRIX( res, 0, 0) << endl;

    
    if (MATRIX( res, 0, 0 ) != IGRAPH_INFINITY) {
      // int igraph_get_shortest_paths(const igraph_t *graph,
      // 				  igraph_vector_ptr_t *vertices,
      // 				  igraph_vector_ptr_t *edges,
      // 				  igraph_integer_t from, const igraph_vs_t to,
      // 				  igraph_neimode_t mode,
      // 				  igraph_vector_long_t *predecessors,
      // 				  igraph_vector_long_t *inbound_edges);
      igraph_vector_ptr_t vertices;
      igraph_vector_t v;
      igraph_vector_init( &v, 0 );
      igraph_vector_ptr_init( &vertices, 0 );
      igraph_vector_ptr_push_back( &vertices, &v );
      igraph_get_shortest_paths_dijkstra( &G_copy,
					  &vertices,
					  NULL,
					  s,
					  igraph_vss_1( t ),
					  &iv_ew,
					  IGRAPH_OUT,
					  NULL,
					  NULL );

  
      for (unsigned j = 0; j < igraph_vector_size( &v );
	   ++j ) {
	cout << igraph_vector_e( &v, j ) << ' ';

      }
    
      cout << endl;

      igraph_vector_destroy( &v );
      igraph_vector_ptr_destroy( &vertices );
    }
    igraph_vector_destroy( &iv_ew );
    igraph_matrix_destroy( &res );
  }
  

  
}

void max_flow(
	      igraph_t& G,
	      vector <myint >& W,
	      vector <node_pair>& v_S
	      ) {
  //need to modify G to create
  //a suitable instance of max flow
  igraph_t G_copy;
  igraph_copy( &G_copy, &G );

  //for each node not equal to a target pair,
  //split it into two
  //one node for in edges, one for out
  vector <myint> v_targets;
  for (unsigned i = 0; i < v_S.size(); ++i ) {
    v_targets.push_back( v_S[i].s );
    v_targets.push_back( v_S[i].t );
  }
  
  myint n = igraph_vcount( &G_copy );
  unsigned n_added = 0;
  ivector tmp_edges;
  ivector edges_to_remove;
  igraph_vector_init( &tmp_edges, 0 );
  igraph_vector_init( &edges_to_remove, 0 );
  ivector edges_to_add;
  igraph_vector_init( &edges_to_add, 0 );
  
  vector< node_edge > v_map;
  
  for (myint i = 0; i < n; ++i) {
    if (!vcontain( v_targets, i ) ) {
      //i is not a target
      //add two vertices v_i, w_i
      igraph_add_vertices( &G_copy, 2, 0 );
      myint v_i = n + n_added;
      myint w_i = n + n_added + 1;
      n_added += 2;

      node_edge n_i;
      n_i.n = i;
      n_i.v_n = v_i;
      n_i.w_n = w_i;
      v_map.push_back( n_i );
      //get in neighbors of i, make them in neighbors of
      //v_i
      ivector in_neis;
      igraph_vector_init( &in_neis, 0 );
      igraph_neighbors( &G_copy, &in_neis, i, IGRAPH_IN );
      for (unsigned j = 0; j < igraph_vector_size( &in_neis ); ++j) {
	igraph_vector_push_back( &edges_to_add,
				 VECTOR( in_neis )[ j ] );
	igraph_vector_push_back( &edges_to_add,
				 v_i );
	//igraph_add_edge(&G_copy, VECTOR( in_neis )[ j ], v_i );
      }
      
      //get out_neighbors of i, ...
      ivector out_neis;
      igraph_vector_init( &out_neis, 0 );
      igraph_neighbors( &G_copy, &out_neis, i, IGRAPH_OUT );
      for (unsigned j = 0; j < igraph_vector_size( &out_neis ); ++j) {
	//igraph_add_edge(&G_copy, VECTOR( out_neis )[ j ], w_i );
	igraph_vector_push_back( &edges_to_add,
				 VECTOR( out_neis )[ j ] );
	igraph_vector_push_back( &edges_to_add,
				 w_i );
	
      }
      
      //add an edge between v_i, w_i
      //      igraph_add_edge( &G_copy, v_i, w_i );

      igraph_vector_push_back( &edges_to_add,
			       v_i );
      igraph_vector_push_back( &edges_to_add,
			       w_i );
      
      //remove the edges incident with i
      igraph_incident( &G_copy, &tmp_edges, i, IGRAPH_ALL );
      for (unsigned j = 0; j < igraph_vector_size( &tmp_edges ); ++j ) {
	igraph_vector_push_back( &edges_to_remove, VECTOR( tmp_edges )[j]);
      }
      
    }
  }

  igraph_delete_edges( &G_copy, igraph_ess_vector( &edges_to_remove ) );
  igraph_add_edges( &G_copy, &edges_to_add, 0);
  igraph_vector_destroy( &edges_to_add );
  igraph_vector_destroy( &edges_to_remove );
  igraph_vector_destroy( &tmp_edges );

  cerr << "Preprocessing to create max flow instanced completed.\n";
  //ready to run max flow
  ivector v_cut;
  igraph_vector_init( &v_cut, 0 );

  myint s = v_S[0].s;
  myint t = v_S[0].t;
  igraph_maxflow( &G_copy,
		  NULL,
		  NULL,
		  &v_cut,
		  NULL,
		  NULL,
		  s,
		  t,
		  NULL,
		  NULL );

  W.clear();
  myint head, tail;
  bool b_found;
  myint index = 0;
  for (myint i = 0; i < igraph_vector_size( &v_cut ); ++i) {
    igraph_edge( &G_copy, VECTOR( v_cut )[i], &head, &tail );
    //    cerr << "h t " << head << ' ' << tail << endl;
    for (unsigned j = 0; j < v_map.size(); ++j ) {
      b_found = ( ( head == v_map[j].v_n ) || ( head == v_map[j].w_n ) );
      b_found = b_found || ( ( tail == v_map[j].v_n ) || ( tail == v_map[j].w_n ) );
      //b_found = ( (head == v_map[j].v_n ) && (tail == v_map[j].w_n ) );
      if (b_found) {
	index = j;
	break;
      }
    }

    W.push_back( v_map[ index ].n );
  }

  //remove duplicates...
  set< myint > aset( W.begin(), W.end() );
  W.assign( aset.begin(), aset.end() );
  
  igraph_vector_destroy( &v_cut );
}

void T_round(
	     vector< myint >& W,
	     igraph_t& G,
	     vector< vector < myint > >& vpaths,
	     vector< double >& v_node_costs
	     //	     GLPK_path& solver //should already be initialized
	     ) {
  W.clear();
  
  //find highest frequency path
  unsigned max_freq = 0;
  unsigned freq_i = 0;
  for (unsigned i = 0; i < vpaths.size(); ++i ) {
    freq_i = vpaths[i].size();
    if (freq_i > max_freq)
      max_freq = freq_i;
  }

  myint n = igraph_vcount( &G );
  
  //get the LP solution
  if (vpaths.size() > 0) {
    GLPK_path solver( vpaths, n, v_node_costs );
    vector< double > W_LP;
    solver.LP_solve( W_LP );


    //perform the rounding
    for (unsigned i = 0; i < n; ++i) {
      if ( W_LP[ i ] > 1.0 / max_freq )
	W.push_back( i );
    }
  }
}

bool test_problem_feasibility(
			      igraph_t& G,
			      vector< node_pair >& v_S,
			      vector< vector< double > >& wA,
			      double T
			      ) {
  vector< myint > W;
  
  vector < double > npaths; 
  igraph_t G_copy;
  igraph_copy( &G_copy, &G );

  vector <myint > v_terminals;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    myint tmp = v_S[i].s;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
    tmp = v_S[i].t;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
  }

  vector <myint> path;
  double prob;
  bool b_sample = false;
  vector< double > v_ew;
  bool bcont = !pairs_T_sep( G_copy, v_S, T, wA );
  myint n = igraph_vcount( &G_copy );
  double frac_valid;
  unsigned count = 0;
  myint max_v;

  myint s,t;
 
  while( bcont ) {
    weight_vector_from_matrix( G_copy, v_ew, wA );
    //we couldn't find any valid sample paths
    //calculate a shortest path and remove
    //the first node on it
    max_v = -1;
    for (unsigned ii = 0; ii < v_S.size(); ++ii) {
      s = v_S[ii].s;
      t = v_S[ii].t;
	
      if ( get_shortest_path( path, s, t, G_copy, wA ) < T ) {
	if (!vcontain( v_terminals, path[1] ) )
	    max_v = path[1]; //take the first vertex not s
      } 
    }

    if (max_v == -1) {
      //problem, a terminal must be preventing a feasible solution...
      return false;
    }
      
    remove_vertex( G_copy, max_v );
    W.push_back( max_v );
    
    bcont = !pairs_T_sep( G_copy, v_S, T, wA );

  }

  //we've constructed a feasible solution
  //out of non-terminal nodes
  return true;
}

bool SP_heuristic(
		  igraph_t& G,
		  vector< node_pair >& v_S,
		  vector< vector< double > >& wA,
		  double T,
		  vector< myint >& W
		  ) {
  W.clear();
  
  vector < double > npaths; 
  igraph_t G_copy;
  igraph_copy( &G_copy, &G );

  vector <myint > v_terminals;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    myint tmp = v_S[i].s;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
    tmp = v_S[i].t;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
  }

  vector <myint> path;
  double prob;
  bool b_sample = false;
  vector< double > v_ew;
  bool bcont = !pairs_T_sep( G_copy, v_S, T, wA );
  myint n = igraph_vcount( &G_copy );
  double frac_valid;
  unsigned count = 0;
  myint max_v;

  myint s,t;
 
  while( bcont ) {
    weight_vector_from_matrix( G_copy, v_ew, wA );
    //we couldn't find any valid sample paths
    //calculate a shortest path and remove
    //the first node on it
    max_v = -1;
    for (unsigned ii = 0; ii < v_S.size(); ++ii) {
      s = v_S[ii].s;
      t = v_S[ii].t;
	
      if ( get_shortest_path( path, s, t, G_copy, wA ) < T ) {
	if (!vcontain( v_terminals, path[1] ) ) {
	  //find min cost element on path 
	  max_v = path[1]; //take the first vertex not s
	}

      }
    }

    if (max_v == -1) {
      //problem, a terminal must be preventing a feasible solution...
      return false;
    }
      
    remove_vertex( G_copy, max_v );
    W.push_back( max_v );
    
    bcont = !pairs_T_sep( G_copy, v_S, T, wA );

  }

  //we've constructed a feasible solution
  //out of non-terminal nodes
  return true;
}


void greedy_est(
		vector < myint >& W,
		igraph_t& G,
		vector< node_pair >& v_S,
		unsigned L, //number of samples to take for each pair
		vector< double >& v_nc, // node costs
		vector< vector < double > >& wA, //weighted adj. matrix
		double T,
		Sample_type which_sampling = NAIVE
		) {
  W.clear();

  cout << "Starting greedy_est:";
  switch( which_sampling ) {
  case NAIVE: 
    cout << "NAIVE" << endl;
    break;
  case FVALID:
    cout << "FVALID" << endl;
    break;
  }
  
  //the number of paths each vertex is estimated to lie upon
  vector < double > npaths; 
  myint s;
  myint t;
  igraph_t G_copy;
  igraph_copy( &G_copy, &G );

  //preprocessing
  //remove all vertices
  //of distance > T from all terminals
  bool b_preprocess = false;

  vector <myint > v_terminals;

  vector< igraph_matrix_t > res_s;
  vector< igraph_matrix_t > res_t;
  igraph_matrix_t* tmp_res;
  igraph_matrix_t* tmp_res2;

  vector< double > v_ew;
  weight_vector_from_matrix( G_copy, v_ew, wA );
  ivector iv_ew;
  igraph_vector_init( &iv_ew, 0 );
  ivector_from_vector( v_ew, iv_ew );
  for (unsigned i = 0; i < v_S.size(); ++i) {
    myint tmp = v_S[i].s;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );

    tmp = v_S[i].t;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );

    if (b_preprocess) {
      tmp_res = new igraph_matrix_t;
      tmp_res2 = new igraph_matrix_t;

      igraph_matrix_init( tmp_res, 1, 1 );
      igraph_shortest_paths_dijkstra( &G,
				      tmp_res,
				      igraph_vss_1( v_S[i].s ),
				      igraph_vss_all(),
				      &iv_ew,
				      IGRAPH_OUT
				      );

      igraph_matrix_init( tmp_res2, 1, 1 );
      igraph_shortest_paths_dijkstra( &G,
				      tmp_res2,
				      igraph_vss_1( v_S[i].t ),
				      igraph_vss_all(),
				      &iv_ew,
				      IGRAPH_IN
				      );

      res_s.push_back( (*tmp_res) );
      res_t.push_back( (*tmp_res2) );
     
    }
    
  }

  if (b_preprocess) {
    myint n = igraph_vcount( &G_copy );

    vector< myint > v_to_remove;
    for (myint j = 0; j < n; ++j ) {
      bool remove_j = true;
      for (unsigned i = 0; i < res_s.size(); ++i) {
	if ( MATRIX( (res_s[i]), 0, j ) < T )
	  remove_j = false;
	if ( MATRIX( (res_t[i]), 0, j ) < T )
	  remove_j = false;
      }

      if (remove_j)
	v_to_remove.push_back( j );
    }

    cout << "Preprocessing removed " << v_to_remove.size() << " vertices" << endl;

    remove_vertices( G_copy, v_to_remove );
    
  }

  igraph_vector_destroy( &iv_ew );
  for (unsigned i = 0; i < res_s.size(); ++i) {
    igraph_matrix_destroy( &(res_s[i]) );
    igraph_matrix_destroy( &(res_t[i]) );
    //    delete &(res_s[i]);
    //    delete &(res_t[i]);
  }

  vector <myint> path;
  double prob;
  bool b_sample = false;
  bool bcont = !pairs_T_sep( G_copy, v_S, T, wA );

  myint n = igraph_vcount( &G_copy );
  double frac_valid;
  unsigned count = 0;
  unsigned max_backtracks = 1;
  // if( bcont) {
 
  //   if (which_sampling == FVALID) {
  //     //we need to choose max_backtracks
  //     cout << "Choosing max_backtracks..." << endl;
  //     do {
  // 	max_backtracks *= 5;
  // 	npaths.assign( n, 0.0 );
  // 	frac_valid = 0.0;
  // 	for (unsigned i = 0; i < v_S.size(); ++i) {
  // 	  s = v_S[i].s;
  // 	  t = v_S[i].t;

  // 	  thread* sample_threads = new thread[ nthreads ];
  // 	  unsigned Lprime =  (unsigned)( L / ((double) nthreads) ) + 1;
  // 	  for (unsigned j = 0; j < nthreads; ++j) {
  // 	    sample_threads[ j ] =
  // 	      thread(
  // 		     L_samples,
  // 		     which_sampling,
  // 		     ref( G_copy ),
  // 		     s,
  // 		     t,
  // 		     ref( v_ew ),
  // 		     T, Lprime,
  // 		     ref( npaths ),
  // 		     ref( frac_valid ),
  // 		     ref( max_backtracks ),
  // 		     ref( W ) );
	  
  // 	  }

  // 	  for (unsigned j = 0; j < nthreads; ++j)
  // 	    sample_threads[j].join();

  // 	  delete [] sample_threads;
  // 	}

  //     } while ( frac_valid / L < 0.01 );

  //     cout << "max_backtracks = " << max_backtracks << endl;
  //   }
    
  // }

  max_backtracks = 10;

  while( bcont ) {
    frac_valid = 0.0;

    myint max_v;
    double max_p;
    //    unsigned n_attempts = 0;
    do {
      npaths.assign( n, 0.0 );

      for (unsigned i = 0; i < v_S.size(); ++i) {
	s = v_S[i].s;
	t = v_S[i].t;

	thread* sample_threads = new thread[ nthreads ];
	unsigned Lprime =  (unsigned)( L / ((double) nthreads) ) + 1;
	for (unsigned j = 0; j < nthreads; ++j) {
	  sample_threads[ j ] =
	    thread(
		   L_samples,
		   which_sampling,
		   ref( G_copy ),
		   s,
		   t,
		   ref( v_ew ),
		   T, Lprime,
		   ref( npaths ),
		   ref( frac_valid ),
		   ref( max_backtracks ),
		   ref( W ) );
	  
	}

	for (unsigned j = 0; j < nthreads; ++j)
	  sample_threads[j].join();

	delete [] sample_threads;
      }


      //    cout << frac_valid << endl;
      //remove vertex that is estimated to lie on the most valid paths
      //excluding endpoints
      //weighted version is most cost-effective node
      max_p = 0.0;
      max_v = -1;
      for (unsigned i = 0; i < npaths.size(); ++i) {
	if (!vcontain( v_terminals, (myint) i ) ) {
	  if ( npaths[i] / v_nc[i] > max_p ) {
	    max_p = npaths[i] / v_nc[i];
	    max_v = i;
	  }
	}
      }

    } while ( false );

    //remove max_v
    if (max_v == -1) {
      if (which_sampling == FVALID) {
	bcont = !pairs_T_sep( G_copy, v_S, T, wA );

      } else {
	bcont = !pairs_T_sep( G_copy, v_S, T, wA );
      }

    } else {
      cout << max_v << ' ' << frac_valid << ' '; cout.flush();
      remove_vertex( G_copy, max_v );
      weight_vector_from_matrix( G_copy, v_ew, wA );

      W.push_back( max_v );
    }
  }
  
}

void greedy_enum(
		 //the chosen set of vertices
		 vector < myint >& W, 
		 igraph_t& G,
		 vector< vector < myint > >& vpaths,
		 vector< vector < unsigned > >& v_path_membership,
		 vector< double >& v_node_costs
		 ) {

  W.clear(); 
  myint n = igraph_vcount( &G );
  
  vector< bool > is_covered( vpaths.size(), false );
  unsigned n_covered = 0;
  double max_value;
  myint max_vertex;
  while ( vcontain( is_covered, false ) ) {
     //there remain paths to be covered
    //find the best vertex
    max_vertex = -1;
    max_value = 0;
    for (myint i = 0; i < n; ++i) {
      if (v_node_costs[i] < (double) ( n - 1) ) { //exclude target pairs
	n_covered = 0;
	for (unsigned j = 0; j < v_path_membership[ i ].size(); ++j) {
	  if ( !(is_covered[ v_path_membership[i][j] ]) ) {
	    ++n_covered;
	  }
	}
	double value = n_covered / v_node_costs[ i ];
	if ( value >= max_value ) {
	  max_value = value;
	  max_vertex = i;
	}
      }
    }

    //Choose vertex max_vertex into the covering
    if (max_vertex == -1) {
      cerr << "mayday\n";
      exit(1);
    }
    W.push_back( max_vertex );
    for (unsigned k = 0; k < v_path_membership[ max_vertex ].size(); ++k) {
      is_covered[ v_path_membership[max_vertex][k] ] = true;
    }
    
  }
}


void parse_input(
		 string& in_params,
		 string& fname,
		 string& s_outfile,
		 string& s_T,
		 string& s_npairs,
		 string& s_nreps,
		 string& s_max_mins,
		 string& s_alpha,
		 string& s_mc,
		 string& s_is_weighted,
		 string& s_which_sampling,
		 string& s_SPh
) {
  istringstream iss;
  iss.str( in_params );
  
  iss >> fname;
  iss >> s_outfile;
  iss >> s_T;
  iss >> s_npairs;
  iss >> s_nreps;
  iss >> s_max_mins;
  iss >> s_alpha;
  iss >> s_mc;
  iss >> s_is_weighted;
  iss >> s_which_sampling;
  iss >> s_SPh;
}

int main( int argc, char** argv ) {
  
  if (argc < 5) {
    cerr << "Usage: " << argv[0]
	 << " <graph specification>"
	 << " <output filename>"
	 << " <T>"
	 << " <npairs>"
	 << " <nreps>" 
	 << " <max_mins>"
	 << " <alpha>"
	 << " <mc={yes,no}>"
	 << " <is_weighted={yes,no}>"
	 << " <which_sampling={0=NAIVE,1=FVALID,2=ALL}>"
	 << " <SPh={yes,no}>"
	 << endl;
    exit(1);
  }

  string in_params;
  
  for (unsigned i = 1; i < argc; ++i) {
    if (i == 1) {
      in_params = argv[i];
    } else {
      in_params += argv[i];
    }

    in_params += " ";
  }

  cout << "Input params: " << in_params << endl;

  string fname;
  string s_T;
  string s_npairs, s_nreps, s_max_mins, s_alpha, s_mc, s_is_weighted, s_which_sampling, s_SPh;
  string s_outfile;

  parse_input( in_params, fname, s_outfile, s_T, s_npairs, s_nreps, s_max_mins, s_alpha, s_mc,
	       s_is_weighted, s_which_sampling, s_SPh );

  myint n;
  igraph_t G;
  double p;  
  bool wint = false;
  igraph_vector_t wint_x;
  igraph_vector_t wint_y;
  igraph_vector_init( &wint_x, 0 );
  igraph_vector_init( &wint_y, 0 );

  if (fname.substr(0, 2) == "ER") {

    size_t pos_colon = fname.find_first_of( ':' );
    string s_n = fname.substr(2, (pos_colon - 2));
    string s_p = fname.substr( pos_colon + 1 );
    p = stod( s_p );
    n = stoi( s_n );
    igraph_erdos_renyi_game( &G, IGRAPH_ERDOS_RENYI_GNP,
			     n, p,
			     false,    //directed
			     false );  //no self loops 
  } else {
    if (fname.substr(0 ,2 ) == "FF") {
      size_t pos_colon = fname.find_first_of( ':' );
      string s_n = fname.substr(2, (pos_colon - 2));
      string s_p = fname.substr( pos_colon + 1 );
      p = stod( s_p );
      n = stoi( s_n );
      igraph_forest_fire_game( &G, 
			       n, 
			       p,
			       2,
			       3,
			       false );    //directed

    } else {
      if (fname.substr(0 ,2 ) == "BA") {
	size_t pos_colon = fname.find_first_of( ':' );
	string s_n = fname.substr(2, (pos_colon - 2));
	string s_p = fname.substr( pos_colon + 1 );
	p = stod( s_p );
	n = stoi( s_n );
	igraph_barabasi_game( &G, 
			      n, 
			      p,
			      0.1 * n,
			      NULL,
			      true,
			      1,
			      false, //directed
			      IGRAPH_BARABASI_PSUMTREE,
			      NULL);  
      } else {
	if (fname.substr(0 ,2 ) == "WT") {
	  wint = true;
	  size_t pos_colon = fname.find_first_of( ':' );
	  string s_n = fname.substr(2, (pos_colon - 2));
	  string s_p = fname.substr( pos_colon + 1 );
	  p = stod( s_p );
	  n = stoi( s_n );
	  //geometric random graph with radius p 

	  igraph_grg_game( &G, 
			   n, 
			   p,
			   false, //not a torus
			   &wint_x, &wint_y);  

	} else {

	  FILE* fp;
	  fp = fopen( fname.c_str(), "r" );
	  igraph_read_graph_edgelist( &G, fp, 0, true );
	  fclose( fp );
	}
      }
    }
  }

  double T = stod( s_T );
  double alpha = stod( s_alpha );
  unsigned npairs = stoi( s_npairs );
  unsigned nreps = stoi( s_nreps );
  unsigned max_mins = stoi( s_max_mins );
  bool b_mc = false;
  if (s_mc == "yes")
    b_mc = true;

  bool b_SPh = false;
  if (s_SPh == "yes")
    b_SPh = true;

  unsigned is_weighted;
  if (s_is_weighted == "yes") 
    is_weighted = 1;
  else
    is_weighted = 0;

  Sample_type which_sampling = static_cast< Sample_type >( stoi( s_which_sampling ) );

  vector < node_pair > v_S;
  vector < myint > v_targets;

  double avg_t_enum = 0.0;
  double avg_t_greedy_enum = 0.0;
  double avg_c_greedy_enum = 0.0;

  presult avg_greedy_enum;
  avg_greedy_enum.alg_name = "g_en";
  avg_greedy_enum.sln_cost = 0.0;
  avg_greedy_enum.run_time = 0.0;

  presult avg_opt;
  avg_opt.alg_name = "opt";
  avg_opt.sln_cost = 0.0;
  avg_opt.run_time = 0.0;

  presult avg_Fround;
  avg_Fround.alg_name = "rnd";
  avg_Fround.sln_cost = 0.0;
  avg_Fround.run_time = 0.0;

  presult avg_max_flow;
  avg_max_flow.alg_name = "mc";
  avg_max_flow.sln_cost = 0.0;
  avg_max_flow.run_time = 0.0;

  presult avg_grd_est_NAIVE;
  avg_grd_est_NAIVE.alg_name = "g_sNAIVE";
  avg_grd_est_NAIVE.sln_cost = 0.0;
  avg_grd_est_NAIVE.run_time = 0.0;

  presult avg_grd_est_FVALID;
  avg_grd_est_FVALID.alg_name = "g_sFVALID";
  avg_grd_est_FVALID.sln_cost = 0.0;
  avg_grd_est_FVALID.run_time = 0.0;

  presult avg_SPh;
  avg_SPh.alg_name = "SP_h";
  avg_SPh.sln_cost = 0.0;
  avg_SPh.run_time = 0.0;

  vector < presult > v_res;
  for (unsigned rep = 0; rep < nreps; ++rep ) {
    bool b_feasible = false;
    vector< double > v_node_costs;
    vector< double > v_edge_weights;
    vector< vector < double > > weighted_Adj;
    myint m;
    do {
      v_S.clear();
      v_targets.clear();
      std::uniform_int_distribution< unsigned > dis0( 0, unsigned (n - 1 ) );
      for (unsigned i = 0; i < npairs; ++i) {

	node_pair p1;
	unsigned tmp;
	//choose s
	do {
	  tmp = dis0( gen );
	} while( vcontain( v_targets, myint( tmp ) ) );
	p1.s = tmp;
	v_targets.push_back( tmp );
	//choose t
	do {
	  tmp = dis0( gen );
	} while( vcontain( v_targets, myint ( tmp ) ) );

	p1.t = tmp;
	v_targets.push_back( tmp );
	v_S.push_back( p1 );
      }
  
      //vertex costs
      v_node_costs.assign( n, 1.0 );
      if (!wint) {
	assign_costs ( v_node_costs, v_S, n, is_weighted );
      } else {
	assign_wint_costs ( G, 
			    v_node_costs, 
			    v_S, 
			    n, 
			    p,
			    wint_x, 
			    wint_y );
      }

      igraph_simplify( &G, true, true, 0 ); //necessary after the wint assignment
    
      //remove edges between target pairs
      remove_edges_between_pairs( G, v_S );

      //edge weights
      n = igraph_vcount( &G );
      m = igraph_ecount( &G );
      v_edge_weights.clear();
      weighted_Adj.clear();
      assign_random_weights(G,
			    v_edge_weights,
			    weighted_Adj );
  
      cout << "Testing feasibility of pair choice v_S..." << endl;
      b_feasible = test_problem_feasibility( G, v_S, weighted_Adj, T );
  
    } while( !b_feasible );

    cout << "Feasible instance constructed." << endl;
  
    //enumerate paths
    n = igraph_vcount( &G );
    vector< myint > path;
    vector< vector < myint > > vpaths;
    vector< unsigned > v_empty;
    vector< vector < unsigned > > v_path_membership( n, v_empty );

    cout << "Starting path enumeration..." << endl;
    clock_t t_start = clock();
    vector< myint > v_neis;
    thread* enum_threads = new thread[ nthreads ];
    chrono::seconds max_secs( 60 * max_mins );
    chrono::high_resolution_clock::time_point wall_start = chrono::high_resolution_clock::now();
    bool b_enum_success;
    for (unsigned i = 0; i < v_S.size(); ++i) {
      cout << "pair " << i << endl;
      myint s = v_S[i].s;
      get_out_neighbors( G, s, v_neis );
      for (unsigned j = 0; j < nthreads; ++j) {
	enum_threads[j] = thread( multi_list_paths,
				  ref( b_enum_success ),
				  ref( max_secs ),
				  ref( wall_start ),
				  ref( v_neis ), 
				  ref( G ), 
				  ref( vpaths ), 
				  ref( v_path_membership ),
				  ref( s ), 
				  ref( v_S[i].t ), 
				  T, 
				  ref( v_edge_weights ) );
      }
      for (unsigned j = 0; j < nthreads; ++j)
	enum_threads[j].join();
    }

    delete [] enum_threads;

    double t_path_enum = double (clock() - t_start) / CLOCKS_PER_SEC;
    cout << "...done." << endl;
    avg_t_enum += t_path_enum;
    // cout << vpaths.size() << endl;
    // for (unsigned i = 0; i < vpaths.size(); ++i) {
    //   print_vector( vpaths[i] );
    // }

    presult tmp_result;

    vector< myint > W;
    double t_elapsed;
    if (b_enum_success) { //enumeration completed, so we can run these algorithms
      t_start = clock();
      greedy_enum( W, G, vpaths, v_path_membership,
		   v_node_costs );
      t_elapsed = double (clock() - t_start) / CLOCKS_PER_SEC;
      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;

      //test feasibility of solution
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "greedy_en";
      tmp_result.sln_cost = cost_vector( W, v_node_costs ) ;
      tmp_result.run_time = t_elapsed + t_path_enum;
      v_res.push_back( tmp_result );


      avg_greedy_enum.sln_cost += tmp_result.sln_cost;
      avg_greedy_enum.run_time += tmp_result.run_time;

      t_start = clock();
      if (vpaths.size() > 0) {
	GLPK_path solver( vpaths, n, v_node_costs );
	solver.GLPK_solve( W );
      } else {
	W.clear();
      }
      t_elapsed = double (clock() - t_start) / CLOCKS_PER_SEC;
      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;
 
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "optimal";
      tmp_result.sln_cost = cost_vector( W, v_node_costs ) ;
      tmp_result.run_time = t_elapsed + t_path_enum;
      v_res.push_back( tmp_result );

      avg_opt.sln_cost += tmp_result.sln_cost;
      avg_opt.run_time += tmp_result.run_time;

      //O(T) rounding
      W.clear();
      cout << "Starting F_round..." << endl;
      t_start = clock();
      T_round( W, G, vpaths, v_node_costs );
      t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;

      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "F_round";
      tmp_result.sln_cost = cost_vector( W, v_node_costs ) ;
      tmp_result.run_time = t_elapsed + t_path_enum;
      v_res.push_back( tmp_result );

      avg_Fround.sln_cost += tmp_result.sln_cost;
      avg_Fround.run_time += tmp_result.run_time;

    } //end if (b_enum_success)  
    //max flow algorithm
    //only run if we have exactly one pair to cut
    if (b_mc) {
      if (v_S.size() == 1) {
	t_start = clock();
	max_flow( G, W, v_S );
	t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
	cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
	print_vector( W );
	cout << endl;
	test_feasibility( G, W, weighted_Adj, v_S );

	tmp_result.alg_name = "min_cut";
	tmp_result.sln_cost = cost_vector( W, v_node_costs ) ;
	tmp_result.run_time = t_elapsed;
	v_res.push_back( tmp_result );

	avg_max_flow.sln_cost += tmp_result.sln_cost;
	avg_max_flow.run_time += tmp_result.run_time;
      }
    }

    //Shortest path heuristic
    if (b_SPh) {
      t_start = clock();
      SP_heuristic( G, v_S,weighted_Adj, T, W );
      t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
  
      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "SPh";
      tmp_result.sln_cost = cost_vector( W, v_node_costs );
      tmp_result.run_time = t_elapsed;
      v_res.push_back( tmp_result );

      avg_SPh.sln_cost += tmp_result.sln_cost;
      avg_SPh.run_time += tmp_result.run_time;
    }
    //Naive estimation greedy
    cout << "Starting estimation algs..." << endl;
  
    unsigned L = static_cast< unsigned >( log ( 2 * n * n ) / (alpha * alpha) );
    cout << "L = " << L << endl;
    switch( which_sampling ) {
    case NAIVE:
      t_start = clock();
      greedy_est( W, G, v_S, L, v_node_costs, weighted_Adj, T, NAIVE );
      t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
  
      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "g_sNAIVE";
      tmp_result.sln_cost = cost_vector( W, v_node_costs );
      tmp_result.run_time = t_elapsed;
      v_res.push_back( tmp_result );

      avg_grd_est_NAIVE.sln_cost += tmp_result.sln_cost;
      avg_grd_est_NAIVE.run_time += tmp_result.run_time;
      break;
    case FVALID:
      t_start = clock();
      greedy_est( W, G, v_S, L, v_node_costs, weighted_Adj, T, FVALID );
      t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
  
      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "g_sFVALID";
      tmp_result.sln_cost = cost_vector( W, v_node_costs );
      tmp_result.run_time = t_elapsed;
      v_res.push_back( tmp_result );

      avg_grd_est_FVALID.sln_cost += tmp_result.sln_cost;
      avg_grd_est_FVALID.run_time += tmp_result.run_time;
      break;
    case ALL:
      Sample_type sam_method = NAIVE;
      t_start = clock();
      greedy_est( W, G, v_S, L, v_node_costs, weighted_Adj, T, sam_method );
      t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
  
      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "g_sNAIVE";
      tmp_result.sln_cost = cost_vector( W, v_node_costs );
      tmp_result.run_time = t_elapsed;
      v_res.push_back( tmp_result );

      avg_grd_est_NAIVE.sln_cost += tmp_result.sln_cost;
      avg_grd_est_NAIVE.run_time += tmp_result.run_time;

      sam_method = FVALID;

      t_start = clock();
      greedy_est( W, G, v_S, L, v_node_costs, weighted_Adj, T, sam_method );
      t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
  
      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "g_sFVALID";
      tmp_result.sln_cost = cost_vector( W, v_node_costs );
      tmp_result.run_time = t_elapsed;
      v_res.push_back( tmp_result );

      avg_grd_est_FVALID.sln_cost += tmp_result.sln_cost;
      avg_grd_est_FVALID.run_time += tmp_result.run_time;
      break;
    }

    print_results( v_res, cout, 10, true );
    v_res.clear();
  }

  presult tmp_result;
  tmp_result.alg_name = "n";
  tmp_result.sln_cost = n;
  tmp_result.run_time = n;
  tmp_result.type = "param";
  tmp_result.ptype = "int";
  v_res.push_back( tmp_result );

  tmp_result.alg_name = "p";
  tmp_result.sln_cost = p;
  tmp_result.run_time = p;
  tmp_result.ptype = "float";
  v_res.push_back( tmp_result );

  tmp_result.alg_name = "T";
  tmp_result.sln_cost = T;
  tmp_result.run_time = T;
  tmp_result.ptype = "float";
  v_res.push_back( tmp_result );


  tmp_result.alg_name = "alpha";
  tmp_result.sln_cost = alpha;
  tmp_result.run_time = alpha;
  tmp_result.ptype = "float";
  v_res.push_back( tmp_result );

  tmp_result.alg_name = "nreps";
  tmp_result.sln_cost = nreps;
  tmp_result.run_time = nreps;
  tmp_result.ptype = "int";
  v_res.push_back( tmp_result );

  tmp_result.alg_name = "max_mins";
  tmp_result.sln_cost = max_mins;
  tmp_result.run_time = max_mins;
  tmp_result.ptype = "int";
  v_res.push_back( tmp_result );

  tmp_result.alg_name = "npairs";
  tmp_result.sln_cost = npairs;
  tmp_result.run_time = npairs;
  tmp_result.ptype = "int";
  v_res.push_back( tmp_result );

  tmp_result.alg_name = "weighted";
  tmp_result.sln_cost = is_weighted;
  tmp_result.run_time = is_weighted;
  tmp_result.ptype = "int";
  v_res.push_back( tmp_result );

  tmp_result.alg_name = "wsample";
  tmp_result.sln_cost = static_cast< double > ( which_sampling );
  tmp_result.run_time = static_cast< double > ( which_sampling );
  tmp_result.ptype = "int";
  v_res.push_back( tmp_result );

  avg_greedy_enum.sln_cost /= nreps;
  avg_greedy_enum.run_time /= nreps;
  avg_opt.sln_cost /= nreps;
  avg_opt.run_time /= nreps;
  avg_Fround.sln_cost /= nreps;
  avg_Fround.run_time /= nreps;
  avg_max_flow.sln_cost /= nreps;
  avg_max_flow.run_time /= nreps;
  avg_grd_est_NAIVE.sln_cost /= nreps;
  avg_grd_est_NAIVE.run_time /= nreps;
  avg_grd_est_FVALID.sln_cost /= nreps;
  avg_grd_est_FVALID.run_time /= nreps;
  avg_SPh.sln_cost /= nreps;
  avg_SPh.run_time /= nreps;

  v_res.push_back( avg_greedy_enum );
  v_res.push_back( avg_opt );
  v_res.push_back( avg_Fround );
  v_res.push_back( avg_max_flow );
  v_res.push_back( avg_grd_est_NAIVE );
  v_res.push_back( avg_grd_est_FVALID );
  v_res.push_back( avg_SPh );

  bool b_print_header;
  if (file_exists ( s_outfile )) {
    b_print_header = false;
  }
  else {
    b_print_header = true;
  }

  ofstream ofile( s_outfile.c_str(), ios::app );
  print_results_no_formatting( v_res, ofile, 10, b_print_header );
  ofile.close();

  return 0;
}

