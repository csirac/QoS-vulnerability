#include <iostream>
#include <cstdio>
#include <string>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <igraph.h>
#include <vector>
#include <random>
#include <set>
#include "GLPK_path.hpp"
#include <iomanip>
#include <ctime>
#include <thread>
#include <mutex>
#include <chrono>

using namespace std;
typedef igraph_integer_t myint;
typedef igraph_vector_t ivector;

//global random number generator
std::random_device rd;
std::mt19937 gen(rd());

//global thread mutex
std::mutex mtx;
//global nthreads
unsigned nthreads = 7;

struct presult {
  string alg_name;
  double sln_cost;
  double run_time;
};

struct node_pair {
  myint s;
  myint t;
};

inline bool file_exists (const std::string& name) {
  if (FILE *file = fopen(name.c_str(), "r")) {
    fclose(file);
    return true;
  } else {
    return false;
  }   
}

void remove_vertex( // preserves vertex ids
		   igraph_t& G,
		   myint v
		    ) {
  ivector eids;
  igraph_vector_init( &eids, 0 );
  igraph_incident( &G, &eids, v, IGRAPH_ALL );

  igraph_delete_edges( &G, igraph_ess_vector( &eids ) );
  igraph_vector_destroy( &eids );
}

 

void print_results( vector < presult >& v_res, ostream& os,
		    int col_width = 10,
		    bool b_header = false )

{
  if (b_header) {
    //print header
    os << "#";
    for (unsigned i = 0; i < v_res.size(); ++i) {
      os << setw( col_width );
      os << 2*i + 1;
      os << setw( col_width );
      os << 2*i + 2;
    }
    os << endl;
    os << "#";
    for (unsigned i = 0; i < v_res.size(); ++i) {
      os << setw( col_width );
      os << v_res[i].alg_name;
    }
    
    for (unsigned i = 0; i < v_res.size(); ++i) {
      os << setw( col_width );
      os << v_res[i].alg_name;

    }

    os << endl;
  }

  for (unsigned i = 0; i < v_res.size(); ++i) {
    os << setw( col_width ) << fixed << setprecision( 2 );
    os << v_res[i].sln_cost;
  }

  for (unsigned i = 0; i < v_res.size(); ++i) {
    os << setw( col_width ) << fixed << setprecision( 2 );
    os << v_res[i].run_time;
  }

  os << endl;
}

template <typename T>
void print_vector( vector< T >& v, ostream& os = cout ) {
  for (unsigned i = 0; i < v.size(); ++i) {
    os << v[i] << ' ';

  }

  os << endl;
}

template <typename T>
bool vcontain( vector< T >& v, T val ) {
  for (unsigned i = 0; i < v.size(); ++i) {
    if (v[i] == val)
      return true;
  }

  return false;
}

struct node_edge {
  myint n;
  myint v_n; //(v_n, w_n) is the edge replacing node n
  myint w_n;
};

double path_length(
		   igraph_t& G,
		   vector< myint >& path,
		   vector< double >& v_ew //edge weights
		   ) {
  double length = 0.0;
  for (unsigned i = 0; i < (path.size() - 1);
       ++i) {
    myint eid;
    myint n_from = path[i];
    myint n_to = path[i + 1];
    igraph_get_eid( &G, &eid, n_from, n_to, true, true );
    length += v_ew[ eid ];
  }

  return length;
}

bool rec_sample( igraph_t& G,
		 vector< myint >& path,
		 myint& t,
		 double& prob, //the function calling should pass 1.0
		 vector< double >& v_ew,
		 double& T
	    ){
  myint last_vertex = path.back();

  ivector out_neis;
  igraph_vector_init( &out_neis, 0 );
  vector< myint > v_neis;
  //sample the next node
  igraph_neighbors( &G, &out_neis, last_vertex, IGRAPH_OUT );

  //only want neighbors not currently in the path
  for (unsigned i = 0; i < igraph_vector_size( &out_neis ); ++i) {
    if ( !vcontain( path, ((myint) VECTOR( out_neis )[i] )) ) {
      v_neis.push_back( VECTOR( out_neis )[i] );
    }
  }

  if (v_neis.size() == 0) {
    //this path cannot continue without a cycle
    igraph_vector_destroy( &out_neis );
    return false;
  }

  //until successfully making it to t,
  //we will sample each neighbor
  
  //which neighbors we have tried
  vector< bool > b_tried ( v_neis.size(), false );
  unsigned n_left = v_neis.size(); //neighbors left
  std::uniform_int_distribution< unsigned > dist(0, v_neis.size() - 1 );
  unsigned next_vertex;
  double old_prob = prob;
  prob *= ( 1.0 / v_neis.size() );
  unsigned tmp;
  do {
    //pick a neighbor uniformly randomly

    do {
      tmp = dist( gen );
      
    } while(
	    ( b_tried[ tmp ] == true ) 
	    );
    
    next_vertex = v_neis[ tmp ];
    n_left = n_left - 1;
    path.push_back( next_vertex );
    b_tried[ tmp ] = true;
    
    if (next_vertex == t) {
      //we have reached the destination
      igraph_vector_destroy( &out_neis );
      return true;
    } else {
      if ( path_length( G, path, v_ew ) < T ) {
	if ( rec_sample( G, path, t, prob, v_ew, T ) ) {
	  //a valid path has been found this way
	  //so quit
	  return true;
	} else {
	  //no valid path this way
	  //backtrack
	  path.pop_back();
	}
      } else {
	//cannot continue this way, threshold exceeded
	//backtrack
	path.pop_back();
      }
    }
  } while (n_left > 0);

  //if we make it here, there are no neighbors
  //left to try. We need to backtrack last_vertex
  //reset prob
  prob = old_prob;
  return false;
}



bool sample_path_2(igraph_t& G,
		 myint s, myint t, double& prob, vector< myint >& path,
		 double T, vector< double >& v_ew ) {
  path.clear();
  path.push_back( s );
  prob = 1.0;

  ivector out_neis;
  igraph_vector_init( &out_neis, 0 );
  vector< myint > v_neis;
  while ( path_length( G, path, v_ew ) < T ) {
    myint last_vertex = path.back();
    v_neis.clear();
    //sample the next node
    igraph_neighbors( &G, &out_neis, last_vertex, IGRAPH_OUT );

    //only want neighbors not currently in the path
    for (unsigned i = 0; i < igraph_vector_size( &out_neis ); ++i) {
      if ( !vcontain( path, ((myint) VECTOR( out_neis )[i] )) ) {
	v_neis.push_back( VECTOR( out_neis )[i] );
      }
    }

    if (v_neis.size() == 0) {
      //this path cannot continue without a cycle
      igraph_vector_destroy( &out_neis );
      return false;
    }
    
    //pick a neighbor uniformly randomly
    std::uniform_int_distribution< unsigned > dist(0, v_neis.size() - 1 );
    unsigned next_vertex = v_neis[ dist( gen ) ];
    prob *= ( 1.0 / v_neis.size() );
    path.push_back( next_vertex );
    if (next_vertex == t) {
      igraph_vector_destroy( &out_neis );
      return true;
    }
  }

  //path length is \ge T, no valid paths from this point
  igraph_vector_destroy( &out_neis );
  return false;

}

bool sample_path(igraph_t& G,
		 myint s, myint t, 
		 double& prob, vector< myint >& path,
		 double T, vector< double >& v_ew ) {
  path.clear();
  path.push_back( s );
  prob = 1.0;

  ivector out_neis;
  igraph_vector_init( &out_neis, 0 );
  vector< myint > v_neis;
  while ( path_length( G, path, v_ew ) < T ) {
    myint last_vertex = path.back();
    v_neis.clear();
    //sample the next node
    igraph_neighbors( &G, &out_neis, last_vertex, IGRAPH_OUT );

    //only want neighbors not currently in the path
    for (unsigned i = 0; i < igraph_vector_size( &out_neis ); ++i) {
      if ( !vcontain( path, ((myint) VECTOR( out_neis )[i] )) ) {
	v_neis.push_back( VECTOR( out_neis )[i] );
      }
    }

    if (v_neis.size() == 0) {
      //this path cannot continue without a cycle
      igraph_vector_destroy( &out_neis );
      return false;
    }
    
    //pick a neighbor uniformly randomly
    std::uniform_int_distribution< unsigned > dist(0, v_neis.size() - 1 );
    unsigned next_vertex = v_neis[ dist( gen ) ];
    prob *= ( 1.0 / v_neis.size() );
    path.push_back( next_vertex );
    if (next_vertex == t) {
      igraph_vector_destroy( &out_neis );
      return true;
    }
  }

  //path length is \ge T, no valid paths from this point
  igraph_vector_destroy( &out_neis );
  return false;

}

void L_samples (
		bool which_method,
		igraph_t& G,
		myint s,
		myint t,
		vector< double >& v_ew,
		double T, unsigned L,
		vector< double >& npaths,
		double& n_valid) {
  myint n = igraph_vcount( &G );
  vector< double > my_npaths( n, 0.0 );
  bool b_sample;
  vector< myint > path;
  double prob;
  unsigned u_valid = 0;
  for (unsigned i = 0; i < L; ++i) {
    //    if ( i % ( unsigned ( 0.2 * L ) ) == 0 ) {
      //      cout << ((double) i) / L << "    \r";
      //      cout.flush();
    //    }
    path.clear();
    prob = 1.0;
    if (which_method) {
      path.push_back( s );
      b_sample = rec_sample( G, path, t, prob, v_ew, T );
    } else {
      b_sample = sample_path( G,
			      s, t, prob, path,
			      T, v_ew );
    }

    if (b_sample) { //if the sample is a valid path
      //first node is s, last is t exclude those nodes
      ++u_valid;
      //      cout << s << ' ';
      for (unsigned k = 1; k < (path.size() - 1); ++k) {
	//for each node on the path, update its estimator
	my_npaths[ path[ k ] ] += 1.0 / ( prob ); // / ( prob );
	//	cout << path[k] << ' ';
      }
      //      cout << t << endl;
    }
  }
  
  mtx.lock();
  for (unsigned i = 0; i < npaths.size(); ++i) {
    npaths[i] += my_npaths[i];
  }
  n_valid += static_cast< double >( u_valid );
  mtx.unlock();
}


void remove_edges_between_pairs(
				//the graph
				igraph_t& G,
				//the set of target pairs
				vector< node_pair >& v_S
				) {
  myint s_i, t_i;
  myint eid;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    s_i = v_S[i].s;
    t_i = v_S[i].t;

    //determine if an edge exists between this pair
    //if so, there is no way to pseudo-cut them
    //without removing one of the pair
    igraph_get_eid( &G, &eid, s_i, t_i, true, false );

    //if the edge does not exist, eid = -1
    if (eid != -1) {
      //the edge exists, so we need to remove it
      igraph_delete_edges( &G, igraph_ess_1( eid ) );
    }
  }
}

void weight_vector_from_matrix(
			       igraph_t& G,
			       vector< double >& v_ew,
			       vector< vector < double > >& wA ) {
  myint n = igraph_vcount( &G );
  myint m = igraph_ecount( &G );
  myint eid;
  v_ew.assign( m, 1.0 );
  for (myint i = 0; i < n; ++i ) {
    for (myint j = 0; j < n; ++j ) {
      igraph_get_eid( &G, &eid, i, j, true, false );
      if (eid != -1) {
	//this edge exists, so let's assign the weight
	v_ew[ eid ] = wA[i][j];
      }
    }
  }
  
}

template <typename T>
void ivector_from_vector(
			 vector< T >& v_cpp,
			 //iv should be initialized and empty
			 ivector& iv 
			 ) {
  for (unsigned i = 0; i < v_cpp.size(); ++i) {
    igraph_vector_push_back( &iv, v_cpp[i] );
  }
}

template <typename T>
void vector_from_ivector(
			 vector< T >& v_cpp,
			 //iv should be initialized and empty
			 ivector& iv 
			 ) {
  for (unsigned i = 0; i < igraph_vector_size( &iv ); ++i) {
    v_cpp.push_back( (T)( VECTOR( iv )[i]  ));
  }
}

void get_out_neighbors(
		       igraph_t& G,
		       myint& v,
		       vector< myint >& v_neis ) {
  v_neis.clear();
  ivector neis;
  igraph_vector_init( &neis, 0 );
  igraph_neighbors( &G, &neis, v, IGRAPH_OUT );
  
  vector_from_ivector( v_neis, neis );
  igraph_vector_destroy( &neis );
}

double get_shortest_path(
			 vector< myint >& path,
			 myint s,
			 myint t,
			 igraph_t& G,
			 vector< vector< double > >& wA ) {
  path.clear();
  vector< double > v_ew;
  weight_vector_from_matrix( G, v_ew, wA );
  ivector iv_ew;
  igraph_vector_init( &iv_ew, 0 );
  ivector_from_vector( v_ew, iv_ew );

  // //first check if the distance is IGRAPH_INFINITY
  // igraph_matrix_t res;
  // igraph_matrix_init( &res, 1, 1 );
  // igraph_shortest_paths_dijkstra( &G_copy,
  // 				  &res,
  // 				  igraph_vss_1(s),
  // 				  igraph_vss_1(t),
  // 				  &iv_ew,
  // 				  IGRAPH_OUT
  // 				  );
    
  // if ( MATRIX( res, 0, 0) != IGRAPH_INFINITY ) {
    //a path exists, so find it
    igraph_vector_ptr_t vertices;
    igraph_vector_t v;
    igraph_vector_init( &v, 0 );
    igraph_vector_ptr_init( &vertices, 0 );
    igraph_vector_ptr_push_back( &vertices, &v );
    igraph_get_shortest_paths_dijkstra( &G,
					&vertices,
					NULL,
					s,
					igraph_vss_1( t ),
					&iv_ew,
					IGRAPH_OUT,
					NULL,
					NULL );

  
    for (unsigned j = 0; j < igraph_vector_size( &v );
	 ++j ) {
      path.push_back( igraph_vector_e( &v, j ) );
    }
    
    igraph_vector_destroy( &v );
    igraph_vector_destroy( &iv_ew );
    igraph_vector_ptr_destroy( &vertices );

    if (path.size() > 0) {
      return path_length( G, path, v_ew );
    } else {
      return IGRAPH_INFINITY;
    }
  // } else {

  // }
}

bool pairs_T_sep2(
		 igraph_t& G,
		 vector< node_pair >& v_S,
		 double T,
		 vector < vector < double > >& wA
		 ) {
  

}

bool pairs_T_sep(
		 igraph_t& G,
		 vector< node_pair >& v_S,
		 double T,
		 vector < vector < double > >& wA
		 ) {
  vector< double > v_ew;
  weight_vector_from_matrix( G, v_ew, wA );
  ivector iv_ew;
  igraph_vector_init( &iv_ew, 0 );
  ivector_from_vector( v_ew, iv_ew );

  igraph_matrix_t res;
  igraph_matrix_init( &res, 1, 1 );
  myint s, t;
  bool rvalue = true;
  for (unsigned i = 0; i < v_S.size(); ++i ) {
    s = v_S[i].s;
    t = v_S[i].t;
    igraph_shortest_paths_dijkstra( &G,
    				    &res,
    				    igraph_vss_1(s),
    				    igraph_vss_1(t),
    				    &iv_ew,
    				    IGRAPH_OUT
    				    );
    
    if ( MATRIX( res, 0, 0) < T )
      rvalue = false;
  }

  igraph_matrix_destroy( &res );
  igraph_vector_destroy( &iv_ew );

  return rvalue;
}

void assign_random_weights(
			   igraph_t& G,
			   vector< double >& v_ew,
			   vector< vector < double > >& wA ) {
  std::uniform_real_distribution<> dis(0,1);
  
  myint n = igraph_vcount( &G );
  myint m = igraph_ecount( &G );

  v_ew.assign( m, 1.0 );
  vector < double > v_n( n, 1.0 );
  wA.assign( n, v_n );
  myint eid;
  for (myint i = 0; i < n; ++i ) {
    for (myint j = 0; j < n; ++j ) {
      wA[i][j] = 1.0 + dis( gen ); //Should be a random weight
    }
  }

  weight_vector_from_matrix( G, v_ew, wA );
  
}

void assign_costs( vector< double >& v_nc,
		   vector< node_pair >& v_S,
		   myint n ) {
  std::uniform_real_distribution<> dis(0,1);
  
  vector< myint > pair_members;
  v_nc.assign( n, 1.0 );
  for (unsigned i = 0; i < v_S.size(); ++i ) {
    v_nc[ v_S[ i ].s ] = (double) n;
    v_nc[ v_S[ i ].t ] = (double) n;
  }
  
   for (unsigned i = 0; i < v_nc.size(); ++i) {
     if ( v_nc[i] < (double) n ) {
       v_nc[ i ] = dis( gen ); //1.0
     }
   }
}

void assign_wint_costs( vector< double >& v_nc,
			vector< node_pair >& v_S,
			myint n,
			ivector& wint_x,
			ivector& wint_y ) {
  std::uniform_real_distribution<> dis(0,1);
  
  vector< myint > pair_members;
  v_nc.assign( n, 1.0 );
  for (unsigned i = 0; i < v_S.size(); ++i ) {
    v_nc[ v_S[ i ].s ] = (double) n;
    v_nc[ v_S[ i ].t ] = (double) n;
  }

  vector <myint > v_terminals;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    myint tmp = v_S[i].s;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
    tmp = v_S[i].t;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
  }

 
   for (unsigned i = 0; i < v_nc.size(); ++i) {
     if ( v_nc[i] < (double) n ) {
       v_nc[ i ] = 1.0; //dis( gen ); //1.0
     }
   }

  //pick drones
   double drone_frac = 0.1;
   double sat_frac = 0.01;
   myint n_drones = static_cast< myint > ( drone_frac * n );
   myint n_sat = static_cast< myint > ( sat_frac * n );

   //now edit both connections and costs for 
   //drones, sats
   myint n_skip = 0;
   for (myint i = 0; i < n_drones; ++i) {
     while ( vcontain( v_terminals, i + n_skip ) )
       ++n_skip;
     //we've found a non-terminal
     //make it a drone
     for (myint j = 0; j < n; ++j) {
       
       
     }
   }
}


double cost_vector( vector< myint >& W,
		    vector< double >& v_nc ) {
  double rvalue = 0.0;
  for (unsigned i = 0; i < W.size(); ++i) {
    rvalue += v_nc[ W[i] ];
  }

  return rvalue;
}

bool list_paths(
		std::chrono::seconds& max_time,
		chrono::high_resolution_clock::time_point& t_start,
		unsigned t_call_count,
		igraph_t& G,
		vector< vector < myint > >& vpaths,
		//vector recording which paths each vertex
		//lies upon
		//needs to be initialized with empty vectors
		vector< vector < unsigned > >& v_path_membership,
		//path is a list of vertex ids
		vector< myint > path, 
		//the vertex at which to terminate
		myint& end,
		//the upper bound on path length
		double T,
		vector< double >& v_ew //edge weights
		) {
  t_call_count += 1;
  if (t_call_count > 0) { //don't want to check the time every call
    chrono::high_resolution_clock::time_point t_now = chrono::high_resolution_clock::now();
    if ( chrono::duration_cast< chrono::seconds > ( t_now - t_start ) > max_time ) {
      //we have run out of time
      return false;
    }

    //    t_call_count = 0;
  }

  myint last_vertex = path.back();
  path.push_back( -1 ); //reserve a potential next spot in the path
  //for each neighbor of last_vertex
  ivector neis;
  igraph_vector_init( &neis, 0 );
  igraph_neighbors( &G, &neis, last_vertex, IGRAPH_OUT );
  for (myint i = 0; i < igraph_vector_size( &neis ); ++i) {
    myint current_neighbor = VECTOR( neis )[i];
    //need to make sure the path doesn't already contain current_neighbor
    if (!(vcontain( path, current_neighbor))) {
      //then we can add the vertex to the path, as long as doing so
      //does not exceed the distance constraint
      //for now, unweighted distance
      path.back() = current_neighbor;
      if ( path_length( G, path, v_ew ) < T) {
	//have we reached the destination? 
	if ( current_neighbor == end ) {
	  //we have found a valid path
	  //update the path membership
	  for (unsigned j = 0; j < path.size(); ++j) {
	    v_path_membership[ path[ j ] ].push_back( vpaths.size() );
	    //vpaths.size() will correspond to the new index
	  }

	  vpaths.push_back( path );
	} else {
	  //continue exploring in this direction
	  list_paths( 
		     max_time, t_start, t_call_count,
		     G, vpaths, v_path_membership, path, end, T, v_ew);
	}
      }
    }
    
  }

  igraph_vector_destroy( &neis );
  return true;
}

void multi_list_paths ( 
		       bool& b_success,
		       chrono::seconds& max_time,
			chrono::high_resolution_clock::time_point& t_start,
		       vector< myint >& v_neis,
			igraph_t& G, 
			vector< vector< myint > >& vpaths,
			vector< vector< unsigned > >& v_path_membership,
			myint& start,
			myint& end,
			double T,
			vector< double >& v_ew ) {

  vector< vector < myint > > my_vpaths;
  myint n = igraph_vcount( &G );
  vector< unsigned > empty;
  vector< vector < unsigned > > my_v_path_membership (n, empty );
  vector< myint > path;
  //lock to access v_neis
  mtx.lock();
  while ( v_neis.size() > 0 ) {
    path.clear();
    path.push_back( start );
    path.push_back( v_neis.back() );
    v_neis.pop_back();
    mtx.unlock();

    //now enumerate all paths starting with s0, s1
    list_paths(max_time, t_start, 0, G, my_vpaths, my_v_path_membership, path, end, T, v_ew );
    
    mtx.lock();
    chrono::high_resolution_clock::time_point t_now = chrono::high_resolution_clock::now();

    if ( chrono::duration_cast< chrono::seconds > ( t_now - t_start ) > max_time ) {
      b_success = false;
      mtx.unlock();
      return;
    }

  }
  mtx.unlock();
  cerr << "here\n";
  //enumeration complete, add paths to results
  mtx.lock();
  size_t old_npaths = vpaths.size();
  for (unsigned i = 0; i < my_vpaths.size(); ++i) {
    vpaths.push_back( my_vpaths[i] );
  }

  for (unsigned i = 0; i < v_path_membership.size(); ++i) {
    for (unsigned j = 0; j < my_v_path_membership[i].size(); ++j) {
      v_path_membership[i].push_back( my_v_path_membership[ i ][ j ] + old_npaths );
    }
  }

  b_success = true;
  mtx.unlock();
  cerr << "mult_list returning\n";
}

void test_feasibility( igraph_t& G,
		       vector< myint >& W,
		       vector< vector < double > >& wA,
		       vector< node_pair >& v_S) {
  igraph_t G_copy;
  igraph_copy( &G_copy, &G );
  //delete W
  ivector iv_Wedges;
  igraph_vector_init( &iv_Wedges, 0 );
  ivector tmp_edges;
  igraph_vector_init( &tmp_edges, 0 );
  for (unsigned i = 0; i < W.size(); ++i) {
    igraph_incident( &G, &tmp_edges, W[i], IGRAPH_ALL );
    for (unsigned j = 0; j < igraph_vector_size( &tmp_edges ); ++j ) {
      igraph_vector_push_back( &iv_Wedges, VECTOR( tmp_edges )[j]);
    }
  }

  igraph_delete_edges( &G_copy, igraph_ess_vector( &iv_Wedges ) );

  igraph_vector_destroy( &iv_Wedges );
  // int igraph_shortest_paths_dijkstra(const igraph_t *graph,
  // 				     igraph_matrix_t *res,
  // 				     const igraph_vs_t from,
  // 				     const igraph_vs_t to,
  // 				     const igraph_vector_t *weights,
  // 				     igraph_neimode_t mode);
  

  myint s, t;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    s = v_S[i].s;
    t = v_S[i].t;

    vector< double > v_ew;
    weight_vector_from_matrix( G_copy, v_ew, wA );
    ivector iv_ew;
    igraph_vector_init( &iv_ew, 0 );
    ivector_from_vector( v_ew, iv_ew );
  
    igraph_matrix_t res;
    igraph_matrix_init( &res, 1, 1 );
    igraph_shortest_paths_dijkstra( &G_copy,
    				    &res,
    				    igraph_vss_1(s),
    				    igraph_vss_1(t),
    				    &iv_ew,
    				    IGRAPH_OUT
    				    );
    
    cout << "pair " << i << " (" << s << "," << t << "): "
    	 << MATRIX( res, 0, 0) << endl;

    
    if (MATRIX( res, 0, 0 ) != IGRAPH_INFINITY) {
      // int igraph_get_shortest_paths(const igraph_t *graph,
      // 				  igraph_vector_ptr_t *vertices,
      // 				  igraph_vector_ptr_t *edges,
      // 				  igraph_integer_t from, const igraph_vs_t to,
      // 				  igraph_neimode_t mode,
      // 				  igraph_vector_long_t *predecessors,
      // 				  igraph_vector_long_t *inbound_edges);
      igraph_vector_ptr_t vertices;
      igraph_vector_t v;
      igraph_vector_init( &v, 0 );
      igraph_vector_ptr_init( &vertices, 0 );
      igraph_vector_ptr_push_back( &vertices, &v );
      igraph_get_shortest_paths_dijkstra( &G_copy,
					  &vertices,
					  NULL,
					  s,
					  igraph_vss_1( t ),
					  &iv_ew,
					  IGRAPH_OUT,
					  NULL,
					  NULL );

  
      for (unsigned j = 0; j < igraph_vector_size( &v );
	   ++j ) {
	cout << igraph_vector_e( &v, j ) << ' ';

      }
    
      cout << endl;

      igraph_vector_destroy( &v );
      igraph_vector_ptr_destroy( &vertices );
    }
    igraph_vector_destroy( &iv_ew );
    igraph_matrix_destroy( &res );
  }
  

  
}

void max_flow(
	      igraph_t& G,
	      vector <myint >& W,
	      vector <node_pair>& v_S
	      ) {
  //need to modify G to create
  //a suitable instance of max flow
  igraph_t G_copy;
  igraph_copy( &G_copy, &G );

  //for each node not equal to a target pair,
  //split it into two
  //one node for in edges, one for out
  vector <myint> v_targets;
  for (unsigned i = 0; i < v_S.size(); ++i ) {
    v_targets.push_back( v_S[i].s );
    v_targets.push_back( v_S[i].t );
  }
  
  myint n = igraph_vcount( &G_copy );
  unsigned n_added = 0;
  ivector tmp_edges;
  ivector edges_to_remove;
  igraph_vector_init( &tmp_edges, 0 );
  igraph_vector_init( &edges_to_remove, 0 );
  ivector edges_to_add;
  igraph_vector_init( &edges_to_add, 0 );
  
  vector< node_edge > v_map;
  
  for (myint i = 0; i < n; ++i) {
    if (!vcontain( v_targets, i ) ) {
      //i is not a target
      //add two vertices v_i, w_i
      igraph_add_vertices( &G_copy, 2, 0 );
      myint v_i = n + n_added;
      myint w_i = n + n_added + 1;
      n_added += 2;

      node_edge n_i;
      n_i.n = i;
      n_i.v_n = v_i;
      n_i.w_n = w_i;
      v_map.push_back( n_i );
      //get in neighbors of i, make them in neighbors of
      //v_i
      ivector in_neis;
      igraph_vector_init( &in_neis, 0 );
      igraph_neighbors( &G_copy, &in_neis, i, IGRAPH_IN );
      for (unsigned j = 0; j < igraph_vector_size( &in_neis ); ++j) {
	igraph_vector_push_back( &edges_to_add,
				 VECTOR( in_neis )[ j ] );
	igraph_vector_push_back( &edges_to_add,
				 v_i );
	//igraph_add_edge(&G_copy, VECTOR( in_neis )[ j ], v_i );
      }
      
      //get out_neighbors of i, ...
      ivector out_neis;
      igraph_vector_init( &out_neis, 0 );
      igraph_neighbors( &G_copy, &out_neis, i, IGRAPH_OUT );
      for (unsigned j = 0; j < igraph_vector_size( &out_neis ); ++j) {
	//igraph_add_edge(&G_copy, VECTOR( out_neis )[ j ], w_i );
	igraph_vector_push_back( &edges_to_add,
				 VECTOR( out_neis )[ j ] );
	igraph_vector_push_back( &edges_to_add,
				 w_i );
	
      }
      
      //add an edge between v_i, w_i
      //      igraph_add_edge( &G_copy, v_i, w_i );

      igraph_vector_push_back( &edges_to_add,
			       v_i );
      igraph_vector_push_back( &edges_to_add,
			       w_i );
      
      //remove the edges incident with i
      igraph_incident( &G_copy, &tmp_edges, i, IGRAPH_ALL );
      for (unsigned j = 0; j < igraph_vector_size( &tmp_edges ); ++j ) {
	igraph_vector_push_back( &edges_to_remove, VECTOR( tmp_edges )[j]);
      }
      
    }
  }

  igraph_delete_edges( &G_copy, igraph_ess_vector( &edges_to_remove ) );
  igraph_add_edges( &G_copy, &edges_to_add, 0);
  igraph_vector_destroy( &edges_to_add );
  igraph_vector_destroy( &edges_to_remove );
  igraph_vector_destroy( &tmp_edges );

  cerr << "Preprocessing to create max flow instanced completed.\n";
  //ready to run max flow
  ivector v_cut;
  igraph_vector_init( &v_cut, 0 );

  myint s = v_S[0].s;
  myint t = v_S[0].t;
  igraph_maxflow( &G_copy,
		  NULL,
		  NULL,
		  &v_cut,
		  NULL,
		  NULL,
		  s,
		  t,
		  NULL,
		  NULL );

  W.clear();
  myint head, tail;
  bool b_found;
  myint index = 0;
  for (myint i = 0; i < igraph_vector_size( &v_cut ); ++i) {
    igraph_edge( &G_copy, VECTOR( v_cut )[i], &head, &tail );
    //    cerr << "h t " << head << ' ' << tail << endl;
    for (unsigned j = 0; j < v_map.size(); ++j ) {
      b_found = ( ( head == v_map[j].v_n ) || ( head == v_map[j].w_n ) );
      b_found = b_found || ( ( tail == v_map[j].v_n ) || ( tail == v_map[j].w_n ) );
      //b_found = ( (head == v_map[j].v_n ) && (tail == v_map[j].w_n ) );
      if (b_found) {
	index = j;
	break;
      }
    }

    W.push_back( v_map[ index ].n );
  }

  //remove duplicates...
  set< myint > aset( W.begin(), W.end() );
  W.assign( aset.begin(), aset.end() );
  
  igraph_vector_destroy( &v_cut );
}

void T_round(
	     
	     vector< myint >& W,
	     igraph_t& G,
	     vector< vector < myint > >& vpaths,
	     vector< double >& v_node_costs
	     //	     GLPK_path& solver //should already be initialized
	     ) {
  W.clear();
  
  //find highest frequency path
  unsigned max_freq = 0;
  unsigned freq_i = 0;
  for (unsigned i = 0; i < vpaths.size(); ++i ) {
    freq_i = vpaths[i].size();
    if (freq_i > max_freq)
      max_freq = freq_i;
  }

  myint n = igraph_vcount( &G );
  
  //get the LP solution
  if (vpaths.size() > 0) {
    GLPK_path solver( vpaths, n, v_node_costs );
    vector< double > W_LP;
    solver.LP_solve( W_LP );


    //perform the rounding
    for (unsigned i = 0; i < n; ++i) {
      if ( W_LP[ i ] > 1.0 / max_freq )
	W.push_back( i );
    }
  }
}



void greedy_est(
		vector < myint >& W,
		igraph_t& G,
		vector< node_pair >& v_S,
		unsigned L, //number of samples to take for each pair
		vector< double >& v_nc, // node costs
		vector< vector < double > >& wA, //weighted adj. matrix
		double T,
		bool better_sampling = false
		) {
  W.clear();
  
  //the number of paths each vertex is estimated to lie upon
  vector < double > npaths; 
  myint s;
  myint t;
  igraph_t G_copy;
  igraph_copy( &G_copy, &G );

  vector <myint > v_terminals;
  for (unsigned i = 0; i < v_S.size(); ++i) {
    myint tmp = v_S[i].s;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
    tmp = v_S[i].t;
    if (!vcontain( v_terminals, tmp ))
      v_terminals.push_back( tmp );
    
  }

  vector <myint> path;
  double prob;
  bool b_sample = false;
  vector< double > v_ew;
  bool bcont = !pairs_T_sep( G_copy, v_S, T, wA ); //do we need to run sampling?
  myint n = igraph_vcount( &G_copy );
  double frac_valid;
  unsigned count = 0;
 
  while( bcont ) {
    frac_valid = 0.0;
    npaths.assign( n, 0.0 );
    weight_vector_from_matrix( G_copy, v_ew, wA );
    myint max_v;
    do {
      for (unsigned i = 0; i < v_S.size(); ++i) {
	s = v_S[i].s;
	t = v_S[i].t;

	thread* sample_threads = new thread[ nthreads ];
	unsigned Lprime =  (unsigned)( L / ((double) nthreads) );
	for (unsigned j = 0; j < nthreads; ++j) {
	  sample_threads[ j ] =
	    thread(
		   L_samples,
		   better_sampling,
		   ref( G_copy ),
		   s,
		   t,
		   ref( v_ew ),
		   T, Lprime,
		   ref( npaths ),
		   ref( frac_valid ) );
	  
	}

	for (unsigned j = 0; j < nthreads; ++j)
	  sample_threads[j].join();

	delete [] sample_threads;
      }


      //    cout << frac_valid << endl;
      //remove vertex that is estimated to lie on the most valid paths
      //excluding endpoints
      //weighted version is most cost-effective node
      double max_p = 0.0;
      max_v = -1;
      for (unsigned i = 0; i < npaths.size(); ++i) {
	//      if (!vcontain( v_terminals, i ) ) {
	if ( npaths[i] / v_nc[i] > max_p ) {
	  max_p = npaths[i] / v_nc[i];
	  max_v = i;
	}
	//      }
      }
    } while( max_v == -1 );

    //remove max_v
    if (max_v == -1) {
      if (better_sampling) {
	bcont = false;
	break;
      }
      //we couldn't find any valid sample paths
      //calculate a shortest path and remove
      //the first node on it
      for (unsigned ii = 0; ii < v_S.size(); ++ii) {
	myint s = v_S[ii].s;
	myint t = v_S[ii].t;
	
	if ( get_shortest_path( path, s, t, G_copy, wA ) < T ) {
	  max_v = path[1]; //take the first vertex not s
	}
      }
    }
    
    cout << max_v << ' ' << npaths[ max_v ] << endl;
    remove_vertex( G_copy, max_v );
    W.push_back( max_v );
    
    //calculate if we need to continue
    //    ++count;
    //    if ( count % 5 == 0 ) {
    //    if (!better_sampling)
    bcont = !pairs_T_sep( G_copy, v_S, T, wA );
    //    }
  }
  
}

void greedy_enum(
		 //the chosen set of vertices
		 vector < myint >& W, 
		 igraph_t& G,
		 vector< vector < myint > >& vpaths,
		 vector< vector < unsigned > >& v_path_membership,
		 vector< double >& v_node_costs
		 ) {

  W.clear(); 
  myint n = igraph_vcount( &G );
  
  vector< bool > is_covered( vpaths.size(), false );
  unsigned n_covered = 0;
  double max_value;
  myint max_vertex;
  while ( vcontain( is_covered, false ) ) {
     //there remain paths to be covered
    //find the best vertex
    max_vertex = -1;
    max_value = 0;
    for (myint i = 0; i < n; ++i) {
      if (v_node_costs[i] < 1.5 ) { //exclude target pairs
	n_covered = 0;
	for (unsigned j = 0; j < v_path_membership[ i ].size(); ++j) {
	  if ( !(is_covered[ v_path_membership[i][j] ]) ) {
	    ++n_covered;
	  }
	}
	double value = n_covered / v_node_costs[ i ];
	if ( value >= max_value ) {
	  max_value = value;
	  max_vertex = i;
	}
      }
    }

    //Choose vertex max_vertex into the covering
    if (max_vertex == -1) {
      cerr << "mayday\n";
      exit(1);
    }
    W.push_back( max_vertex );
    for (unsigned k = 0; k < v_path_membership[ max_vertex ].size(); ++k) {
      is_covered[ v_path_membership[max_vertex][k] ] = true;
    }
    
  }
}


void parse_input(
		 string& in_params,
		 string& fname,
		 string& s_outfile,
		 string& s_T,
		 string& s_npairs,
		 string& s_nreps,
		 string& s_max_mins,
		 string& s_alpha,
		 string& s_mc
) {
  istringstream iss;
  iss.str( in_params );
  
  iss >> fname;
  iss >> s_outfile;
  iss >> s_T;
  iss >> s_npairs;
  iss >> s_nreps;
  iss >> s_max_mins;
  iss >> s_alpha;
  iss >> s_mc;
}

int main( int argc, char** argv ) {
  
  if (argc < 5) {
    cerr << "Usage: " << argv[0]
	 << " <graph specification>"
	 << " <output filename>"
	 << " <T>"
	 << " <npairs>"
	 << " <nreps>" 
	 << " <max_mins>"
	 << " <alpha>"
	 << endl;
    exit(1);
  }

  string in_params;
  
  for (unsigned i = 1; i < argc; ++i) {
    if (i == 1) {
      in_params = argv[i];
    } else {
      in_params += argv[i];
    }

    in_params += " ";
  }

  cout << "Input params: " << in_params << endl;

  string fname;
  string s_T;
  string s_npairs, s_nreps, s_max_mins, s_alpha, s_mc;
  string s_outfile;

  parse_input( in_params, fname, s_outfile, s_T, s_npairs, s_nreps, s_max_mins, s_alpha, s_mc );

  myint n;
  igraph_t G;
  double p;  
  bool wint = false;
  igraph_vector_t wint_x;
  igraph_vector_t wint_y;
  igraph_vector_init( &wint_x, 0 );
  igraph_vector_init( &wint_y, 0 );

  if (fname.substr(0, 2) == "ER") {

    size_t pos_colon = fname.find_first_of( ':' );
    string s_n = fname.substr(2, (pos_colon - 2));
    string s_p = fname.substr( pos_colon + 1 );
    p = stod( s_p );
    n = stoi( s_n );
    igraph_erdos_renyi_game( &G, IGRAPH_ERDOS_RENYI_GNP,
			     n, p,
			     false,    //directed
			     false );  //no self loops 
  } else {
    if (fname.substr(0 ,2 ) == "FF") {
      size_t pos_colon = fname.find_first_of( ':' );
      string s_n = fname.substr(2, (pos_colon - 2));
      string s_p = fname.substr( pos_colon + 1 );
      p = stod( s_p );
      n = stoi( s_n );
      igraph_forest_fire_game( &G, 
			       n, 
			       p,
			       2,
			       3,
			       false );    //directed

    } else {
      if (fname.substr(0 ,2 ) == "BA") {
	size_t pos_colon = fname.find_first_of( ':' );
	string s_n = fname.substr(2, (pos_colon - 2));
	string s_p = fname.substr( pos_colon + 1 );
	p = stod( s_p );
	n = stoi( s_n );
	igraph_barabasi_game( &G, 
			      n, 
			      p,
			      0.1 * n,
			      NULL,
			      true,
			      1,
			      false, //directed
			      IGRAPH_BARABASI_PSUMTREE,
			      NULL);  
      } else {
	if (fname.substr(0 ,2 ) == "WT") {
	  wint = true;
	  size_t pos_colon = fname.find_first_of( ':' );
	  string s_n = fname.substr(2, (pos_colon - 2));
	  string s_p = fname.substr( pos_colon + 1 );
	  p = stod( s_p );
	  n = stoi( s_n );
	  //geometric random graph with radius p 

	  igraph_grg_game( &G, 
			   n, 
			   p,
			   false, //not a torus
			   &wint_x, &wint_y);  

	} else {

	  FILE* fp;
	  fp = fopen( fname.c_str(), "r" );
	  igraph_read_graph_edgelist( &G, fp, 0, true );
	  fclose( fp );
	}
      }
    }
  }

  double T = stod( s_T );
  double alpha = stod( s_alpha );
  unsigned npairs = stoi( s_npairs );
  unsigned nreps = stoi( s_nreps );
  unsigned max_mins = stoi( s_max_mins );
  bool b_mc = false;
  if (s_mc == "yes")
    b_mc = true;

  vector < node_pair > v_S;
  vector < myint > v_targets;

  double avg_t_enum = 0.0;
  double avg_t_greedy_enum = 0.0;
  double avg_c_greedy_enum = 0.0;

  presult avg_greedy_enum;
  avg_greedy_enum.alg_name = "g_en";
  avg_greedy_enum.sln_cost = 0.0;
  avg_greedy_enum.run_time = 0.0;

  presult avg_opt;
  avg_opt.alg_name = "opt";
  avg_opt.sln_cost = 0.0;
  avg_opt.run_time = 0.0;

  presult avg_Fround;
  avg_Fround.alg_name = "rnd";
  avg_Fround.sln_cost = 0.0;
  avg_Fround.run_time = 0.0;

  presult avg_max_flow;
  avg_max_flow.alg_name = "mc";
  avg_max_flow.sln_cost = 0.0;
  avg_max_flow.run_time = 0.0;

  presult avg_grd_est;
  avg_grd_est.alg_name = "g_est";
  avg_grd_est.sln_cost = 0.0;
  avg_grd_est.run_time = 0.0;

  vector < presult > v_res;
  for (unsigned rep = 0; rep < nreps; ++rep ) {
    v_S.clear();
    v_targets.clear();
    std::uniform_int_distribution< unsigned > dis0( 0, unsigned (n - 1 ) );
    for (unsigned i = 0; i < npairs; ++i) {

      node_pair p1;
      unsigned tmp;
      //choose s
      do {
	tmp = dis0( gen );
      } while( vcontain( v_targets, myint( tmp ) ) );
      p1.s = tmp;
      v_targets.push_back( tmp );
      //choose t
      do {
	tmp = dis0( gen );
      } while( vcontain( v_targets, myint ( tmp ) ) );

      p1.t = tmp;
      v_targets.push_back( tmp );
      v_S.push_back( p1 );
    }
  
    //remove edges between target pairs
    remove_edges_between_pairs( G, v_S );
    
    //edge weights
    n = igraph_vcount( &G );
    myint m = igraph_ecount( &G );
    vector< double > v_edge_weights;
    vector< vector < double > > weighted_Adj;
    assign_random_weights(G,
			  v_edge_weights,
			  weighted_Adj );
  
  
    //vertex costs
    vector< double > v_node_costs( n, 1.0 );
    if (!wint) {
      assign_costs ( v_node_costs, v_S, n );
    } else {
      assign_wint_costs ( v_node_costs, v_S, n, wint_x, wint_y );
    }
  
    //enumerate paths
    n = igraph_vcount( &G );
    vector< myint > path;
    vector< vector < myint > > vpaths;
    vector< unsigned > v_empty;
    vector< vector < unsigned > > v_path_membership( n, v_empty );

    cout << "Starting path enumeration..." << endl;
    clock_t t_start = clock();
    vector< myint > v_neis;
    thread* enum_threads = new thread[ nthreads ];
    chrono::seconds max_secs( 60 * max_mins );
    chrono::high_resolution_clock::time_point wall_start = chrono::high_resolution_clock::now();
    bool b_enum_success;
    for (unsigned i = 0; i < v_S.size(); ++i) {
      cout << "pair " << i << endl;
      myint s = v_S[i].s;
      get_out_neighbors( G, s, v_neis );
      for (unsigned j = 0; j < nthreads; ++j) {
	enum_threads[j] = thread( multi_list_paths,
				  ref( b_enum_success ),
				  ref( max_secs ),
				  ref( wall_start ),
				  ref( v_neis ), 
				  ref( G ), 
				  ref( vpaths ), 
				  ref( v_path_membership ),
				  ref( s ), 
				  ref( v_S[i].t ), 
				  T, 
				  ref( v_edge_weights ) );
      }
      for (unsigned j = 0; j < nthreads; ++j)
	enum_threads[j].join();
    }

    delete [] enum_threads;

    double t_path_enum = double (clock() - t_start) / CLOCKS_PER_SEC;
  cout << "...done." << endl;
  avg_t_enum += t_path_enum;
  // cout << vpaths.size() << endl;
  // for (unsigned i = 0; i < vpaths.size(); ++i) {
  //   print_vector( vpaths[i] );
  // }

  presult tmp_result;

  vector< myint > W;
  double t_elapsed;
  if (b_enum_success) { //enumeration completed, so we can run these algorithms
    t_start = clock();
    greedy_enum( W, G, vpaths, v_path_membership,
		 v_node_costs );
    t_elapsed = double (clock() - t_start) / CLOCKS_PER_SEC;
    cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
    print_vector( W );
    cout << endl;

    //test feasibility of solution
    test_feasibility( G, W, weighted_Adj, v_S );

    tmp_result.alg_name = "greedy_en";
    tmp_result.sln_cost = cost_vector( W, v_node_costs ) ;
    tmp_result.run_time = t_elapsed + t_path_enum;
    v_res.push_back( tmp_result );

    avg_greedy_enum.sln_cost += tmp_result.sln_cost;
    avg_greedy_enum.run_time += tmp_result.run_time;

    t_start = clock();
    if (vpaths.size() > 0) {
      GLPK_path solver( vpaths, n, v_node_costs );
      solver.GLPK_solve( W );
    } else {
      W.clear();
    }
    t_elapsed = double (clock() - t_start) / CLOCKS_PER_SEC;
    cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
    print_vector( W );
    cout << endl;
 
    test_feasibility( G, W, weighted_Adj, v_S );

    tmp_result.alg_name = "optimal";
    tmp_result.sln_cost = cost_vector( W, v_node_costs ) ;
    tmp_result.run_time = t_elapsed + t_path_enum;
    v_res.push_back( tmp_result );

    avg_opt.sln_cost += tmp_result.sln_cost;
    avg_opt.run_time += tmp_result.run_time;

    //O(T) rounding
    cout << "Starting F_round..." << endl;
    t_start = clock();
    T_round( W, G, vpaths, v_node_costs );
    t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;

    cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
    print_vector( W );
    cout << endl;
    test_feasibility( G, W, weighted_Adj, v_S );

    tmp_result.alg_name = "F_round";
    tmp_result.sln_cost = cost_vector( W, v_node_costs ) ;
    tmp_result.run_time = t_elapsed + t_path_enum;
    v_res.push_back( tmp_result );

    avg_Fround.sln_cost += tmp_result.sln_cost;
    avg_Fround.run_time += tmp_result.run_time;

  } //end if (b_enum_success)  
  //max flow algorithm
  //only run if we have exactly one pair to cut
  if (b_mc) {
    if (v_S.size() == 1) {
      t_start = clock();
      max_flow( G, W, v_S );
      t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
      cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
      print_vector( W );
      cout << endl;
      test_feasibility( G, W, weighted_Adj, v_S );

      tmp_result.alg_name = "min_cut";
      tmp_result.sln_cost = cost_vector( W, v_node_costs ) ;
      tmp_result.run_time = t_elapsed;
      v_res.push_back( tmp_result );

      avg_max_flow.sln_cost += tmp_result.sln_cost;
      avg_max_flow.run_time += tmp_result.run_time;
    }
  }
  
  //Naive estimation greedy
  cout << "Starting gr_sold..." << endl;
  
  unsigned L = static_cast< unsigned >( log ( 2 * n * n ) / (alpha * alpha) );
  cout << "L = " << L << endl;
  t_start = clock();
  greedy_est( W, G, v_S, L, v_node_costs, weighted_Adj, T, false );
  t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
  
  cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
  print_vector( W );
  cout << endl;
  test_feasibility( G, W, weighted_Adj, v_S );

  tmp_result.alg_name = "g_sold";
  tmp_result.sln_cost = cost_vector( W, v_node_costs );
  tmp_result.run_time = t_elapsed;
  v_res.push_back( tmp_result );

  avg_grd_est.sln_cost += tmp_result.sln_cost;
  avg_grd_est.run_time += tmp_result.run_time;


  // //Estimation greedy improved sampling
  // cout << "Starting gr_snew..." << endl;
  // L = 20000;
  // t_start = clock();
  // greedy_est( W, G, v_S, L, v_node_costs, weighted_Adj, T, true );
  // t_elapsed = double ( clock() - t_start ) / CLOCKS_PER_SEC;
  
  // cout << "W (cost " << cost_vector( W, v_node_costs ) << "): ";
  // print_vector( W );
  // cout << endl;
  // test_feasibility( G, W, weighted_Adj, v_S );

  // tmp_result.alg_name = "gr_snew";
  // tmp_result.sln_cost = cost_vector( W, v_node_costs );
  // tmp_result.run_time = t_elapsed;
  // v_res.push_back( tmp_result );
  print_results( v_res, cout, 10, true );
  v_res.clear();
  }

  avg_greedy_enum.sln_cost /= nreps;
  avg_greedy_enum.run_time /= nreps;
  avg_opt.sln_cost /= nreps;
  avg_opt.run_time /= nreps;
  avg_Fround.sln_cost /= nreps;
  avg_Fround.run_time /= nreps;
  avg_max_flow.sln_cost /= nreps;
  avg_max_flow.run_time /= nreps;
  avg_grd_est.sln_cost /= nreps;
  avg_grd_est.run_time /= nreps;

  v_res.push_back( avg_greedy_enum );
  v_res.push_back( avg_opt );
  v_res.push_back( avg_Fround );
  v_res.push_back( avg_max_flow );
  v_res.push_back( avg_grd_est );

  presult tmp_result;
  tmp_result.alg_name = "T";
  tmp_result.sln_cost = T;
  tmp_result.run_time = T;

  v_res.push_back( tmp_result );

  tmp_result.alg_name = "n";
  tmp_result.sln_cost = n;
  tmp_result.run_time = n;

  v_res.push_back( tmp_result );
  tmp_result.alg_name = "p";
  tmp_result.sln_cost = p;
  tmp_result.run_time = p;
  v_res.push_back( tmp_result );

  bool b_print_header;
  if (file_exists ( s_outfile )) {
    b_print_header = false;
  }
  else {
    b_print_header = true;
  }

  ofstream ofile( s_outfile.c_str(), ios::app );
  print_results( v_res, ofile, 10, b_print_header );
  ofile.close();

  return 0;
}

