#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <igraph.h>
#include <vector>

using namespace std;
typedef igraph_integer_t myint;
typedef igraph_vector_t ivector;

template <typename T>
void print_vector( vector< T >& v ) {
  for (unsigned i = 0; i < v.size(); ++i) {
    cout << v[i] << ' ';

  }

  cout << endl;
}

template <typename T>
bool vcontain( vector< T >& v, T val ) {
  for (unsigned i = 0; i < v.size(); ++i) {
    if (v[i] == val)
      return true;
  }

  return false;
}

void list_paths(
		igraph_t& G,
		vector< vector < myint > >& vpaths,
		//needs to be initialized with empty vectors
		vector< vector < unsigned > >& v_path_membership,
		vector< myint > path, //path is a list of vertex ids
		myint& end,
		double T
		) {
  
  myint last_vertex = path.back();
  path.push_back( 0 ); //reserve a potential next spot in the path
  //for each neighbor of last_vertex
  ivector neis;
  igraph_vector_init( &neis, 0 );
  igraph_neighbors( &G, &neis, last_vertex, IGRAPH_OUT );
  for (myint i = 0; i < igraph_vector_size( &neis ); ++i) {
    myint current_neighbor = VECTOR( neis )[i];
    //need to make sure the path doesn't already contain current_neighbor
    if (!(vcontain( path, current_neighbor))) {
      //then we can add the vertex to the path, as long as doing so
      //does not exceed the distance constraint
      //for now, unweighted distance
      path.back() = current_neighbor;
      if (path.size() < T) {
	//have we reached the destination? Rule out path (s,t), it's
	//impossible to cover...
	if ( (current_neighbor == end) && (path.size() > 2) ) {
	  //we have found a valid path
	  //update the path membership
	  for (unsigned j = 0; j < path.size(); ++j) {
	    v_path_membership[ path[ j ] ].push_back( vpaths.size() );
	    //vpaths.size() will correspond to the new index
	  }

	  vpaths.push_back( path );
	} else {
	  //continue exploring in this direction
	  list_paths( G, vpaths, v_path_membership, path, end, T);
	}
      }
    }
    
  }

  igraph_vector_destroy( &neis );
}


void greedy_enum(vector < myint >& W, //the chosen set of vertices
		 igraph_t& G,
		 myint start, myint end, double T) {
  myint n = igraph_vcount( &G );
  vector< myint > path;
  path.push_back( start );
  vector< vector < myint > > vpaths;
  vector< unsigned > v_empty;
  vector< vector < unsigned > > v_path_membership( n, v_empty );
  list_paths( G, vpaths, v_path_membership, path, end, T ); 


  W.clear(); 

  vector< bool > is_covered( vpaths.size(), false );
  unsigned n_covered = 0;
  unsigned max_covered = 0;
  myint max_vertex = 0;
  while ( vcontain( is_covered, false ) ) {
     //there remain paths to be covered
    //find the best vertex
    max_vertex = 0;
    for (myint i = 0; i < n; ++i) {
      //unfair to pick start or end
      if ( (i != start) && (i != end) ) {

	n_covered = 0;
	for (unsigned j = 0; j < v_path_membership[ i ].size(); ++j) {
	  if ( !(is_covered[ v_path_membership[i][j] ]) ) {
	    ++n_covered;
	  }
	}
	if ( n_covered >= max_covered ) {
	  max_covered = n_covered;
	  max_vertex = i;
	}
       }
    }

    //Choose vertex max_vertex into the covering
    W.push_back( max_vertex );
    for (unsigned k = 0; k < v_path_membership[ max_vertex ].size(); ++k) {
      is_covered[ v_path_membership[max_vertex][k] ] = true;
    }
    
  }
}


void parse_input(
		 string& in_params,
		 string& fname,
		 string& s_T
) {
  istringstream iss;
  iss.str( in_params );
  
  iss >> fname;
  iss >> s_T;
}

int main( int argc, char** argv ) {
  
  if (argc < 2) {
    cerr << "Usage: " << argv[0] << " <graph specification> <T>\n";
    exit(0);
  }

  string in_params;
  string fname;
  string s_T;
  
  for (unsigned i = 1; i < argc; ++i) {
    if (i == 1) {
      in_params = argv[i];
    } else {
      in_params += argv[i];
    }

    in_params += " ";
  }

  cout << "Input params: " << in_params << endl;

  parse_input( in_params, fname, s_T );
  igraph_integer_t n;
  igraph_t G;
  
  if (fname.substr(0, 2) == "ER") {
    double p;
    size_t pos_colon = fname.find_first_of( ':' );
    string s_n = fname.substr(2, (pos_colon - 2));
    string s_p = fname.substr( pos_colon + 1 );
    p = stod( s_p );
    n = stoi( s_n );
    igraph_erdos_renyi_game( &G, IGRAPH_ERDOS_RENYI_GNP,
			     n, p,
			     false,    //directed
			     false );  //no self loops 
  }

  double T = stod( s_T );

  vector< myint > W;
  greedy_enum( W, G, 0, 1, 4.0 );
  cout << "W: ";
  print_vector( W );
  cout << endl;
  return 0;
}

