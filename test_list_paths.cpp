#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <igraph.h>
#include <vector>

using namespace std;
typedef igraph_integer_t myint;
typedef igraph_vector_t ivector;

template <typename T>
void print_vector( vector< T >& v ) {
  for (unsigned i = 0; i < v.size(); ++i) {
    cout << v[i] << ' ';

  }

  cout << endl;
}

template <typename T>
bool vcontain( vector< T >& v, T val ) {

  vector< T >::iterator it = v.begin();
  while (it != v.end()) {
    if ((*it) == val)
      return true;
    ++it;
  }

  return false;
}

void list_paths(
		igraph_t& G,
		vector< vector < myint > >& vpaths,
		//needs to be initialized with empty vectors
		vector< vector < unsigned > >& v_path_membership,
		 vector< myint > path, //path is a list of vertex ids
		 myint& end,
		 double T
		 ) {
  print_vector( path );
  myint last_vertex = path.back();
  path.push_back( 0 ); //reserve a potential next spot in the path
  //for each neighbor of last_vertex
  ivector neis;
  igraph_vector_init( &neis, 0 );
  igraph_neighbors( &G, &neis, last_vertex, IGRAPH_OUT );
  for (myint i = 0; i < igraph_vector_size( &neis ); ++i) {
    myint current_neighbor = VECTOR( neis )[i];
    //need to make sure the path doesn't already contain current_neighbor
    if (!(vcontain( path, current_neighbor))) {
      //then we can add the vertex to the path, as long as doing so
      //does not exceed the distance constraint
      //for now, unweighted distance
      path.back() = current_neighbor;
      if (path.size() < T) {
	//have we reached the destination?
	if (current_neighbor == end) {
	  //we have found a valid path
	  //update the path membership
	  for (unsigned j = 0; j < path.size(); ++j) {
	    v_path_membership[ path[ j ] ].push_back( vpaths.size() );
	    //vpaths.size() will correspond to the new index
	  }

	  vpaths.push_back( path );
	} else {
	  //continue exploring in this direction
	  list_paths( G, vpaths, path, end, T);
	}
      }
    }
    
  }
  
}

void greedy_enum(vector < myint >& W, //the chosen set of vertices
		 igraph_t& G,
		 myint start, myint end, double T) {
  vector< myint > path;
  path.push_back( start );
  vector< vector < myint > > vpaths;
  list_paths( G, vpaths, path, end, T );

  W.clear(); 
  myint n = igraph_vcount( &G );
  vector< bool > is_covered( false, vpaths.size() );
  unsigned n_covered = 0;
  unsigned max_covered = 0;
  myint max_vertex = 0;
  while ( vcontain( is_covered, false ) ) {
    //there remain paths to be covered
    //find the best vertex
    max_vertex = 0;
    for (myint i = 0; i < n; ++i) {
      n_covered = 0;
      for (unsigned j = 0; j < v_path_membership[ i ].size(); ++j) {
	if ( !(is_covered[ v_path_membership[i][j] ]) ) {
	  ++n_covered;
	}
      }
      if ( n_covered > max_covered ) {
	max_covered = n_covered;
	max_vertex = i;
      }
    }

    //Choose vertex max_vertex into the covering
    W.push_back( max_vertex );
    for (unsigned k = 0; k < v_path_membership[ k ].size(); ++k) {
      is_covered[ v_path_membership[max_vertex][k] ] = true;
    }
    
  }
}


void parse_input(
		 string& in_params,
		 string& fname
) {
  istringstream iss;
  iss.str( in_params );
  
  iss >> fname;
}

int main( int argc, char** argv ) {
  
  if (argc < 2) {
    cerr << "Usage: " << argv[0] << " input_file\n";
    exit(0);
  }

  string in_params;
  string fname;

  for (unsigned i = 1; i < argc; ++i) {
    if (i == 1) {
      in_params = argv[i];
    } else {
      in_params += argv[i];
    }

    in_params += " ";
  }

  cout << "Input params: " << in_params << endl;
  
  parse_input( in_params, fname );
  igraph_integer_t n;
  igraph_t G;
  
  if (fname.substr(0, 2) == "ER") {
    double p = 1;
    fname = fname.substr(2);
    n = stoi( fname );
    igraph_erdos_renyi_game( &G, IGRAPH_ERDOS_RENYI_GNP,
			     n, p,
			     false,    //directed
			     false );  //no self loops 
  }

  vector< vector < myint > > vpaths;
  vector< myint > path;
  path.push_back( 0 );
  myint end = 1;
  double T = 4.0;
  list_paths( G, vpaths, path, end, T ); 

  for (unsigned i = 0; i < vpaths.size(); ++i) {
    print_vector( vpaths[i] );
  }
  
  return 0;
}

